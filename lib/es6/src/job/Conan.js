// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Path from "path";
import * as Env$Std from "@prefix_re/std/lib/es6/src/Deno/Env.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Dict$Std from "@prefix_re/std/lib/es6/src/Dict.js";
import * as File$Std from "@prefix_re/std/lib/es6/src/Deno/File.js";
import * as Hash$Std from "@prefix_re/std/lib/es6/src/Deno/Hash.js";
import * as Json$Std from "@prefix_re/std/lib/es6/src/Json.js";
import * as List$Std from "@prefix_re/std/lib/es6/src/List.js";
import * as Proc$Std from "@prefix_re/std/lib/es6/src/Deno/Proc.js";
import * as Task$Std from "@prefix_re/std/lib/es6/src/Task.js";
import * as Yaml$Std from "@prefix_re/std/lib/es6/src/Deno/Yaml.js";
import * as Array$Std from "@prefix_re/std/lib/es6/src/Array.js";
import * as Tuple$Std from "@prefix_re/std/lib/es6/src/Tuple.js";
import * as Result$Std from "@prefix_re/std/lib/es6/src/Result.js";
import * as String$Std from "@prefix_re/std/lib/es6/src/String.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function hashN(__x) {
  return Hash$Std.hashN(__x, 3);
}

function getArgs(name, $$int) {
  var args = Deno.env.get("args");
  var args$1 = (args == null) ? [] : String$Std.split(args, " ");
  var sets = Yaml$Std.get($$int, "settings");
  var tmp;
  tmp = typeof sets === "number" || sets.TAG !== /* Object */2 ? Dict$Std.empty(undefined) : Dict$Std.map(sets._0, (function (param) {
            var val = param[1];
            var key = param[0];
            if (typeof val === "number" || !(val.TAG === /* Bool */4 && val._0)) {
              return [
                      key,
                      "False"
                    ];
            } else {
              return [
                      key,
                      "True"
                    ];
            }
          }));
  var sets$1 = Array$Std.map(Dict$Std.toArray(tmp), (function (param) {
          return "-s " + name + ":" + param[0] + "=" + param[1];
        }));
  var opts = Yaml$Std.get($$int, "options");
  var tmp$1;
  tmp$1 = typeof opts === "number" || opts.TAG !== /* Object */2 ? Dict$Std.empty(undefined) : Dict$Std.map(opts._0, (function (param) {
            var val = param[1];
            var key = param[0];
            if (typeof val === "number" || !(val.TAG === /* Bool */4 && val._0)) {
              return [
                      key,
                      "False"
                    ];
            } else {
              return [
                      key,
                      "True"
                    ];
            }
          }));
  var opts$1 = Array$Std.map(Dict$Std.toArray(tmp$1), (function (param) {
          return "-o " + name + ":" + param[0] + "=" + param[1];
        }));
  return Array$Std.flatten([
              args$1,
              sets$1,
              opts$1
            ]);
}

function getRepo(folder) {
  return Result$Std.map(File$Std.read(Path.join(folder, "conanfile.py")), (function (content) {
                if (String$Std.includes(content, "Proprietary")) {
                  return "$CONAN_REPO_INTERNAL";
                } else {
                  return "$CONAN_REPO_PUBLIC";
                }
              }));
}

function getVariables(param) {
  var args = param.args;
  var match = param.base;
  return Dict$Std.fromArray(Array$Std.concat([
                  [
                    "NAME",
                    match.name
                  ],
                  [
                    "VERSION",
                    match.version
                  ],
                  [
                    "FOLDER",
                    match.folder
                  ],
                  [
                    "REPO",
                    param.repo
                  ],
                  [
                    "PROFILE",
                    param.profile
                  ]
                ], Array$Std.empty(args) ? [] : [[
                      "ARGS",
                      Array$Std.join(args, " ")
                    ]]));
}

function init(ints) {
  var exportPkgs = Array$Std.reduce(ints, (function (pkgs, param) {
          var folder = param.folder;
          var version = param.version;
          var name = param.name;
          if (Array$Std.some(pkgs, (function (pkg) {
                    return Caml_obj.caml_equal(pkg, [
                                name + "/" + version + "@",
                                folder
                              ]);
                  }))) {
            return pkgs;
          } else {
            return Array$Std.concat(pkgs, [[
                          name + "/" + version + "@",
                          folder
                        ]]);
          }
        }), []);
  var config = Task$Std.flatMap(Task$Std.fromResult(Result$Std.seq2(Tuple$Std.map2([
                    "CONAN_CONFIG_URL",
                    "CONAN_CONFIG_DIR"
                  ], Env$Std.getError))), (function (param) {
          return Proc$Std.run([
                      "conan",
                      "config",
                      "install",
                      param[0],
                      "-sf",
                      param[1]
                    ]);
        }));
  return Task$Std.flatMap(Task$Std.flatMap(config, (function (param) {
                    return Task$Std.map(Task$Std.fromResult(Result$Std.seq3(Tuple$Std.map3([
                                            "CONAN_LOGIN_USERNAME",
                                            "CONAN_LOGIN_PASSWORD",
                                            "CONAN_REPO_ALL"
                                          ], Env$Std.getError))), (function (param) {
                                  return Proc$Std.run([
                                              "conan",
                                              "user",
                                              param[0],
                                              "-p",
                                              param[1],
                                              "-r",
                                              param[2]
                                            ]);
                                }));
                  })), (function (param) {
                return Task$Std.pool(Array$Std.map(exportPkgs, (function (param, param$1) {
                                  return Proc$Std.run([
                                              "conan",
                                              "export",
                                              param[1],
                                              param[0]
                                            ]);
                                })), navigator.hardwareConcurrency);
              }));
}

function getBuildOrder(ints) {
  var locks = Array$Std.map(ints, (function (param) {
          var match = param.base;
          return match.name + "-" + match.version + "-" + param.hash + ".lock";
        }));
  var bundle = Array$Std.empty(locks) ? Task$Std.to("") : Proc$Std.run(Array$Std.concat([
              "conan",
              "lock",
              "bundle",
              "create",
              "--bundle-out=lock.bundle"
            ], locks));
  return Task$Std.flatMap(Task$Std.flatMap(bundle, (function (param) {
                    return Proc$Std.run([
                                "conan",
                                "lock",
                                "bundle",
                                "build-order",
                                "lock.bundle",
                                "--json=build_order.json"
                              ]);
                  })), (function (param) {
                return Task$Std.fromResult(Result$Std.map(File$Std.read("build_order.json"), (function (content) {
                                  return Array$Std.map(Json$Std.$$Array.get(Json$Std.parse(content)), (function (array) {
                                                return Array$Std.map(Json$Std.$$Array.get(array), Json$Std.$$String.get);
                                              }));
                                })));
              }));
}

function getExtends(param) {
  var profile = param[0];
  var triple = List$Std.fromArray(String$Std.split(profile, "-"));
  var arch;
  if (triple) {
    var match = triple.tl;
    if (match) {
      switch (match.hd) {
        case "armv8" :
            arch = {
              TAG: /* Ok */0,
              _0: "armv8"
            };
            break;
        case "wasm" :
        case "x86_64" :
            arch = {
              TAG: /* Ok */0,
              _0: "x86_64"
            };
            break;
        default:
          arch = {
            TAG: /* Error */1,
            _0: "Could not detect image arch for profile: " + profile
          };
      }
    } else {
      arch = {
        TAG: /* Error */1,
        _0: "Could not detect image arch for profile: " + profile
      };
    }
  } else {
    arch = {
      TAG: /* Error */1,
      _0: "Could not detect image arch for profile: " + profile
    };
  }
  var end = param[1] ? "-bootstrap" : "";
  return Result$Std.map(arch, (function (arch) {
                return [".conan" + "-" + arch + end];
              }));
}

function getJob(ints, buildOrder) {
  var needs = buildOrder[Array$Std.length(buildOrder) - 1 | 0];
  return Array$Std.concat(Array$Std.flatMapWithIndex(buildOrder, (function (index, group) {
                    return Array$Std.flatMap(group, (function (pkg) {
                                  var match = String$Std.split(pkg, "@#");
                                  var match$1;
                                  if (match.length !== 2) {
                                    match$1 = [
                                      "invalid-pkg",
                                      "invalid-rev"
                                    ];
                                  } else {
                                    var pkg$1 = match[0];
                                    var pkgRevision = match[1];
                                    match$1 = [
                                      pkg$1,
                                      pkgRevision
                                    ];
                                  }
                                  var pkgRevision$1 = match$1[1];
                                  var pkg$2 = match$1[0];
                                  var ints$1 = Array$Std.filter(ints, (function (param) {
                                          var match = param.base;
                                          if (pkgRevision$1 === param.revision) {
                                            return pkg$2 === match.name + "/" + match.version;
                                          } else {
                                            return false;
                                          }
                                        }));
                                  return Array$Std.concat(Array$Std.map(ints$1, (function ($$int) {
                                                    var group = buildOrder[index - 1 | 0];
                                                    return Dict$Std.to($$int.base.name + "/" + $$int.base.version + "@" + $$int.hash, {
                                                                extends: $$int.extends,
                                                                variables: Caml_option.some(getVariables($$int)),
                                                                image: undefined,
                                                                tags: undefined,
                                                                script: undefined,
                                                                needs: Array$Std.uniq(Array$Std.concat($$int.base.needs, group !== undefined ? Array$Std.map(group, (function (pkg) {
                                                                                  var match = String$Std.split(pkg, "@#");
                                                                                  if (match.length !== 2) {
                                                                                    return "invalid-pkg";
                                                                                  } else {
                                                                                    return match[0];
                                                                                  }
                                                                                })) : [])),
                                                                services: undefined,
                                                                cache: undefined
                                                              });
                                                  })), [Dict$Std.to(pkg$2, {
                                                    extends: undefined,
                                                    variables: undefined,
                                                    image: undefined,
                                                    tags: ["x86_64"],
                                                    script: ["echo"],
                                                    needs: Array$Std.map(ints$1, (function (foundPkg) {
                                                            return pkg$2 + "@" + foundPkg.hash;
                                                          })),
                                                    services: undefined,
                                                    cache: undefined
                                                  })]);
                                }));
                  })), [Dict$Std.to("conan-upload", {
                    extends: undefined,
                    variables: Caml_option.some(Dict$Std.fromArray([
                              [
                                "CONAN_DATA_PATH",
                                "$CI_PROJECT_DIR/conan_data"
                              ],
                              [
                                "GIT_CLEAN_FLAGS",
                                "-x -f -e $CONAN_DATA_PATH/**"
                              ]
                            ])),
                    image: "registry.gitlab.com/aivero/open-source/contrib/focal-x86_64-dockerfile:master",
                    tags: undefined,
                    script: Array$Std.flatMap(Array$Std.map(Array$Std.flatten(buildOrder), (function (pkg) {
                                var match = String$Std.split(pkg, "@#");
                                if (match.length !== 2) {
                                  return [
                                          "invalid-name",
                                          "invalid-version",
                                          ""
                                        ];
                                }
                                var pkg$1 = match[0];
                                var match$1 = String$Std.split(pkg$1, "/");
                                var match$2 = Array$Std.find(ints, (function (param) {
                                        var match = param.base;
                                        return String$Std.startsWith(pkg$1, match.name + "/" + match.version);
                                      }));
                                if (match$1.length !== 2) {
                                  return [
                                          "invalid-name",
                                          "invalid-version",
                                          ""
                                        ];
                                }
                                var name = match$1[0];
                                var version = match$1[1];
                                if (match$2 !== undefined) {
                                  return [
                                          name,
                                          version,
                                          match$2.repo
                                        ];
                                } else {
                                  return [
                                          "invalid-name",
                                          "invalid-version",
                                          ""
                                        ];
                                }
                              })), (function (param) {
                            var repo = param[2];
                            var version = param[1];
                            var name = param[0];
                            var match = String$Std.match(version, /^[0-9a-f]{40}$/);
                            return Array$Std.concat(["conan upload " + name + "/" + version + "@ --all -c -r " + repo], match !== undefined ? ["conan upload " + name + "/$CI_COMMIT_REF_NAME@ --all -c -r " + repo] : []);
                          })),
                    needs: needs !== undefined ? Array$Std.map(needs, (function (need) {
                              var match = String$Std.split(need, "@#");
                              if (match.length !== 2) {
                                return "invalid_need";
                              } else {
                                return match[0];
                              }
                            })) : [],
                    services: undefined,
                    cache: {
                      key: "$CI_PIPELINE_ID",
                      paths: ["$CONAN_DATA_PATH"]
                    }
                  })]);
}

function getConanInstances($$int) {
  var version = $$int.version;
  var name = $$int.name;
  var repo = getRepo($$int.folder);
  var args = getArgs(name, $$int.modeInt);
  return Task$Std.seq(Array$Std.map($$int.profiles, (function (profile) {
                    var $$extends = getExtends([
                          profile,
                          $$int.bootstrap
                        ]);
                    return Task$Std.flatMap(Task$Std.fromResult(Result$Std.seq2([
                                        $$extends,
                                        repo
                                      ])), (function (param) {
                                  var repo = param[1];
                                  var $$extends = param[0];
                                  var hash = Hash$Std.hashN({
                                        base: $$int,
                                        extends: $$extends,
                                        hash: "",
                                        revision: "",
                                        profile: profile,
                                        repo: repo,
                                        args: args
                                      }, 3);
                                  return Task$Std.flatMap(Task$Std.flatMap(Proc$Std.run(Array$Std.concat([
                                                          "conan",
                                                          "lock",
                                                          "create",
                                                          "--ref=" + name + "/" + version,
                                                          "--build=" + name + "/" + version,
                                                          "--lockfile-out=" + name + "-" + version + "-" + hash + ".lock",
                                                          "-pr=" + profile
                                                        ], args)), (function (param) {
                                                    return Task$Std.fromResult(Result$Std.flatMap(File$Std.read(name + "-" + version + "-" + hash + ".lock"), (function (lock) {
                                                                      var ref = Json$Std.$$Object.get(Json$Std.$$Object.get(Json$Std.$$Object.get(Json$Std.$$Object.get(Json$Std.parse(lock), "graph_lock"), "nodes"), "1"), "ref");
                                                                      if (typeof ref !== "number" && ref.TAG === /* String */0) {
                                                                        var revision = String$Std.split(ref._0, "#")[1];
                                                                        if (revision !== undefined) {
                                                                          return {
                                                                                  TAG: /* Ok */0,
                                                                                  _0: revision
                                                                                };
                                                                        } else {
                                                                          return {
                                                                                  TAG: /* Error */1,
                                                                                  _0: "Invalid lock file: " + name + "-" + version + "-" + hash + ".lock"
                                                                                };
                                                                        }
                                                                      }
                                                                      return {
                                                                              TAG: /* Error */1,
                                                                              _0: "Invalid lock file: " + name + "-" + version + "-" + hash + ".lock"
                                                                            };
                                                                    })));
                                                  })), (function (revision) {
                                                return Task$Std.to({
                                                            base: $$int,
                                                            extends: $$extends,
                                                            hash: hash,
                                                            revision: revision,
                                                            profile: profile,
                                                            repo: repo,
                                                            args: args
                                                          });
                                              }));
                                }));
                  })));
}

function getJobs(ints) {
  var ints$1 = Array$Std.filter(ints, (function ($$int) {
          return $$int.mode === "conan";
        }));
  return Task$Std.flatMap(Task$Std.flatMap(init(ints$1), (function (param) {
                    return Task$Std.map(Task$Std.pool(Array$Std.map(ints$1, (function ($$int, param) {
                                          return getConanInstances($$int);
                                        })), navigator.hardwareConcurrency), Array$Std.flatten);
                  })), (function (ints) {
                if (Array$Std.empty(ints)) {
                  return Task$Std.to([]);
                } else {
                  return Task$Std.map(getBuildOrder(ints), (function (buildOrder) {
                                return getJob(ints, buildOrder);
                              }));
                }
              }));
}

var hashLength = 3;

export {
  hashLength ,
  hashN ,
  getArgs ,
  getRepo ,
  getVariables ,
  init ,
  getBuildOrder ,
  getExtends ,
  getJob ,
  getConanInstances ,
  getJobs ,
  
}
/* path Not a pure module */
