// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Jobt from "./Jobt.js";
import * as Path from "path";
import * as Env$Std from "@prefix_re/std/lib/es6/src/Deno/Env.js";
import * as Int$Std from "@prefix_re/std/lib/es6/src/Int.js";
import * as Profile from "../Profile.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Dict$Std from "@prefix_re/std/lib/es6/src/Dict.js";
import * as File$Std from "@prefix_re/std/lib/es6/src/Deno/File.js";
import * as Hash$Std from "@prefix_re/std/lib/es6/src/Deno/Hash.js";
import * as Json$Std from "@prefix_re/std/lib/es6/src/Json.js";
import * as List$Std from "@prefix_re/std/lib/es6/src/List.js";
import * as Proc$Std from "@prefix_re/std/lib/es6/src/Deno/Proc.js";
import * as Task$Std from "@prefix_re/std/lib/es6/src/Task.js";
import * as Yaml$Std from "@prefix_re/std/lib/es6/src/Deno/Yaml.js";
import * as Array$Std from "@prefix_re/std/lib/es6/src/Array.js";
import * as Tuple$Std from "@prefix_re/std/lib/es6/src/Tuple.js";
import * as Option$Std from "@prefix_re/std/lib/es6/src/Option.js";
import * as Result$Std from "@prefix_re/std/lib/es6/src/Result.js";
import * as String$Std from "@prefix_re/std/lib/es6/src/String.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Console$Std from "@prefix_re/std/lib/es6/src/Console.js";

var $$extends = [
  [
    ".conan",
    {
      extends: Jobt.$$default.extends,
      variables: Caml_option.some(Dict$Std.fromArray([
                [
                  "CONAN_USER_HOME",
                  "$CI_PROJECT_DIR"
                ],
                [
                  "CONAN_DATA_PATH",
                  "$CI_PROJECT_DIR/conan_data"
                ],
                [
                  "CARGO_HOME",
                  "$CI_PROJECT_DIR/.cargo"
                ],
                [
                  "SCCACHE_DIR",
                  "$CI_PROJECT_DIR/.sccache"
                ],
                [
                  "GIT_CLEAN_FLAGS",
                  "-x -f -e $CARGO_HOME/** -e $SCCACHE_DIR/**"
                ],
                [
                  "REPO",
                  "$CONAN_REPO_DEV_PUBLIC"
                ]
              ])),
      image: Jobt.$$default.image,
      tags: Jobt.$$default.tags,
      before_script: Jobt.$$default.before_script,
      script: [
        "alias c=conan",
        "c config install $CONAN_CONFIG_URL -sf $CONAN_CONFIG_DIR",
        "c config set general.default_profile=$PROFILE",
        "c config set storage.path=$CONAN_DATA_PATH",
        "c user $CONAN_LOGIN_USERNAME -p $CONAN_LOGIN_PASSWORD -r $CONAN_REPO_ALL",
        "c user $CONAN_LOGIN_USERNAME -p $CONAN_LOGIN_PASSWORD -r $CONAN_REPO_DEV_ALL",
        "c user $CONAN_LOGIN_USERNAME -p $CONAN_LOGIN_PASSWORD -r $CONAN_REPO_DEV_INTERNAL",
        "c user $CONAN_LOGIN_USERNAME -p $CONAN_LOGIN_PASSWORD -r $CONAN_REPO_DEV_PUBLIC",
        "c create -u . $NAME/$VERSION@ $ARGS",
        "c upload $NAME/$VERSION@ --all -c -r $REPO",
        "[[ -n $UPLOAD_ALIAS ]] && c upload $NAME/$CI_COMMIT_REF_NAME@ --all -c -r $REPO || echo"
      ],
      after_script: Jobt.$$default.after_script,
      needs: Jobt.$$default.needs,
      services: Jobt.$$default.services,
      cache: {
        key: "$CI_RUNNER_EXECUTABLE_ARCH",
        paths: [
          "$CARGO_HOME",
          "$SCCACHE_DIR"
        ]
      },
      retry: {
        max: 2,
        when: [
          "runner_system_failure",
          "stuck_or_timeout_failure"
        ]
      },
      artifacts: {
        expire_in: "1 month",
        paths: [
          "conan_data/$NAME/$VERSION/_/_/build/*/meson-logs/*-log.txt",
          "conan_data/$NAME/$VERSION/_/_/build/*/*/meson-logs/*-log.txt",
          "conan_data/$NAME/$VERSION/_/_/build/*/CMakeFiles/CMake*.log",
          "conan_data/$NAME/$VERSION/_/_/build/*/*/CMakeFiles/CMake*.log",
          "conan_data/$NAME/$VERSION/_/_/build/*/*/config.log"
        ],
        when: "always"
      },
      when: Jobt.$$default.when,
      allow_failure: Jobt.$$default.allow_failure
    }
  ],
  [
    ".conan-x86_64",
    {
      extends: [".conan"],
      variables: Caml_option.some(Dict$Std.fromArray([[
                  "PROFILE",
                  "linux-x86_64"
                ]])),
      image: Result$Std.toOption(Profile.getImage("linux-x86_64", Caml_option.nullable_to_opt(Deno.env.get("CONAN_DOCKER_REGISTRY")), Caml_option.nullable_to_opt(Deno.env.get("CONAN_DOCKER_PREFIX")))),
      tags: Result$Std.toOption(Profile.getTags("linux-x86_64")),
      before_script: Jobt.$$default.before_script,
      script: Jobt.$$default.script,
      after_script: Jobt.$$default.after_script,
      needs: Jobt.$$default.needs,
      services: Jobt.$$default.services,
      cache: Jobt.$$default.cache,
      retry: Jobt.$$default.retry,
      artifacts: Jobt.$$default.artifacts,
      when: Jobt.$$default.when,
      allow_failure: Jobt.$$default.allow_failure
    }
  ],
  [
    ".conan-armv8",
    {
      extends: [".conan"],
      variables: Caml_option.some(Dict$Std.fromArray([[
                  "PROFILE",
                  "linux-armv8"
                ]])),
      image: Result$Std.toOption(Profile.getImage("linux-armv8", Caml_option.nullable_to_opt(Deno.env.get("CONAN_DOCKER_REGISTRY")), Caml_option.nullable_to_opt(Deno.env.get("CONAN_DOCKER_PREFIX")))),
      tags: Result$Std.toOption(Profile.getTags("linux-armv8")),
      before_script: Jobt.$$default.before_script,
      script: Jobt.$$default.script,
      after_script: Jobt.$$default.after_script,
      needs: Jobt.$$default.needs,
      services: Jobt.$$default.services,
      cache: Jobt.$$default.cache,
      retry: Jobt.$$default.retry,
      artifacts: Jobt.$$default.artifacts,
      when: Jobt.$$default.when,
      allow_failure: Jobt.$$default.allow_failure
    }
  ],
  [
    ".conan-x86_64-bootstrap",
    {
      extends: [".conan-x86_64"],
      variables: Jobt.$$default.variables,
      image: Option$Std.map(Result$Std.toOption(Profile.getImage("linux-x86_64", Caml_option.nullable_to_opt(Deno.env.get("CONAN_DOCKER_REGISTRY")), Caml_option.nullable_to_opt(Deno.env.get("CONAN_DOCKER_PREFIX")))), (function (image) {
              return image + "-bootstrap";
            })),
      tags: Jobt.$$default.tags,
      before_script: Jobt.$$default.before_script,
      script: Jobt.$$default.script,
      after_script: Jobt.$$default.after_script,
      needs: Jobt.$$default.needs,
      services: Jobt.$$default.services,
      cache: Jobt.$$default.cache,
      retry: Jobt.$$default.retry,
      artifacts: Jobt.$$default.artifacts,
      when: Jobt.$$default.when,
      allow_failure: Jobt.$$default.allow_failure
    }
  ],
  [
    ".conan-armv8-bootstrap",
    {
      extends: [".conan-armv8"],
      variables: Jobt.$$default.variables,
      image: Option$Std.map(Result$Std.toOption(Profile.getImage("linux-armv8", Caml_option.nullable_to_opt(Deno.env.get("CONAN_DOCKER_REGISTRY")), Caml_option.nullable_to_opt(Deno.env.get("CONAN_DOCKER_PREFIX")))), (function (image) {
              return image + "-bootstrap";
            })),
      tags: Jobt.$$default.tags,
      before_script: Jobt.$$default.before_script,
      script: Jobt.$$default.script,
      after_script: Jobt.$$default.after_script,
      needs: Jobt.$$default.needs,
      services: Jobt.$$default.services,
      cache: Jobt.$$default.cache,
      retry: Jobt.$$default.retry,
      artifacts: Jobt.$$default.artifacts,
      when: Jobt.$$default.when,
      allow_failure: Jobt.$$default.allow_failure
    }
  ]
];

function hashN(__x) {
  return Hash$Std.hashN(__x, 3);
}

function getArgs(name, $$int) {
  var args = Deno.env.get("args");
  var args$1 = (args == null) ? [] : String$Std.split(args, " ");
  var sets = Yaml$Std.get($$int, "settings");
  var tmp;
  tmp = typeof sets === "number" || sets.TAG !== /* Object */2 ? Dict$Std.empty(undefined) : Dict$Std.map(sets._0, (function (param) {
            var val = param[1];
            var key = param[0];
            if (typeof val === "number" || !(val.TAG === /* Bool */4 && val._0)) {
              return [
                      key,
                      "False"
                    ];
            } else {
              return [
                      key,
                      "True"
                    ];
            }
          }));
  var sets$1 = Array$Std.map(Dict$Std.toArray(tmp), (function (param) {
          return "-s " + name + ":" + param[0] + "=" + param[1];
        }));
  var opts = Yaml$Std.get($$int, "options");
  var tmp$1;
  tmp$1 = typeof opts === "number" || opts.TAG !== /* Object */2 ? Dict$Std.empty(undefined) : Dict$Std.map(opts._0, (function (param) {
            var val = param[1];
            var key = param[0];
            if (typeof val === "number" || !(val.TAG === /* Bool */4 && val._0)) {
              return [
                      key,
                      "False"
                    ];
            } else {
              return [
                      key,
                      "True"
                    ];
            }
          }));
  var opts$1 = Array$Std.map(Dict$Std.toArray(tmp$1), (function (param) {
          return "-o " + name + ":" + param[0] + "=" + param[1];
        }));
  return Array$Std.flat([
              args$1,
              sets$1,
              opts$1
            ]);
}

function getRepos(folder) {
  return Result$Std.map(File$Std.read(Path.join(folder, "conanfile.py")), (function (content) {
                if (String$Std.includes(content, "Proprietary")) {
                  return [
                          "$CONAN_REPO_INTERNAL",
                          "$CONAN_REPO_DEV_INTERNAL"
                        ];
                } else {
                  return [
                          "$CONAN_REPO_PUBLIC",
                          "$CONAN_REPO_DEV_PUBLIC"
                        ];
                }
              }));
}

function getVariables(param) {
  var args = param.args;
  var repoDev = param.repoDev;
  var profile = param.profile;
  var match = param.base;
  var version = match.version;
  var tmp;
  switch (profile) {
    case "linux-armv8" :
    case "linux-x86_64" :
        tmp = [];
        break;
    default:
      tmp = [[
          "PROFILE",
          profile
        ]];
  }
  var tmp$1 = repoDev === "$CONAN_REPO_DEV_PUBLIC" ? [] : [[
        "REPO",
        repoDev
      ]];
  var match$1 = String$Std.match(version, /^[0-9a-f]{40}$/);
  return Dict$Std.fromArray(Array$Std.concat(Array$Std.concat(Array$Std.concat(Array$Std.concat([
                              [
                                "NAME",
                                match.name
                              ],
                              [
                                "VERSION",
                                version
                              ]
                            ], tmp), tmp$1), Array$Std.empty(args) ? [] : [[
                          "ARGS",
                          Array$Std.join(args, " ")
                        ]]), match$1 !== undefined ? [[
                      "UPLOAD_ALIAS",
                      "1"
                    ]] : []));
}

function init(ints) {
  var exportPkgs = Array$Std.reduce(ints, (function (pkgs, param) {
          var folder = param.folder;
          var version = param.version;
          var name = param.name;
          if (Array$Std.some(pkgs, (function (pkg) {
                    return Caml_obj.caml_equal(pkg, [
                                name + "/" + version + "@",
                                folder
                              ]);
                  }))) {
            return pkgs;
          } else {
            return Array$Std.concat(pkgs, [[
                          name + "/" + version + "@",
                          folder
                        ]]);
          }
        }), []);
  var config = Task$Std.flatMap(Task$Std.fromResult(Result$Std.seq2(Tuple$Std.map2([
                    "CONAN_CONFIG_URL",
                    "CONAN_CONFIG_DIR"
                  ], Env$Std.getError))), (function (param) {
          return Proc$Std.run([
                      "conan",
                      "config",
                      "install",
                      param[0],
                      "-sf",
                      param[1]
                    ]);
        }));
  return Task$Std.flatMap(Task$Std.flatMap(config, (function (param) {
                    return Task$Std.flatMap(Task$Std.fromResult(Result$Std.seq4(Tuple$Std.map4([
                                            "CONAN_LOGIN_USERNAME",
                                            "CONAN_LOGIN_PASSWORD",
                                            "CONAN_REPO_ALL",
                                            "CONAN_REPO_DEV_ALL"
                                          ], Env$Std.getError))), (function (param) {
                                  var repo_dev = param[3];
                                  var passwd = param[1];
                                  var user = param[0];
                                  return Task$Std.flatMap(Proc$Std.run([
                                                  "conan",
                                                  "user",
                                                  user,
                                                  "-p",
                                                  passwd,
                                                  "-r",
                                                  param[2]
                                                ]), (function (param) {
                                                return Proc$Std.run([
                                                            "conan",
                                                            "user",
                                                            user,
                                                            "-p",
                                                            passwd,
                                                            "-r",
                                                            repo_dev
                                                          ]);
                                              }));
                                }));
                  })), (function (param) {
                return Task$Std.pool(Array$Std.map(exportPkgs, (function (param, param$1) {
                                  return Proc$Std.run([
                                              "conan",
                                              "export",
                                              param[1],
                                              param[0]
                                            ]);
                                })), navigator.hardwareConcurrency);
              }));
}

function getBuildOrder(ints) {
  var locks = Array$Std.map(ints, (function ($$int) {
          var match = $$int.base;
          return match.name + "-" + match.version + "-" + Hash$Std.hashN([
                      $$int.base,
                      $$int.profile
                    ], 3) + ".lock";
        }));
  var bundle = Array$Std.empty(locks) ? Task$Std.to("") : Proc$Std.run(Array$Std.concat([
              "conan",
              "lock",
              "bundle",
              "create",
              "--bundle-out=lock.bundle"
            ], locks));
  return Task$Std.flatMap(Task$Std.flatMap(bundle, (function (param) {
                    return Proc$Std.run([
                                "conan",
                                "lock",
                                "bundle",
                                "build-order",
                                "lock.bundle",
                                "--json=build_order.json"
                              ]);
                  })), (function (param) {
                return Task$Std.fromResult(Result$Std.map(File$Std.read("build_order.json"), (function (content) {
                                  return Array$Std.map(Json$Std.$$Array.get(Json$Std.parse(content)), (function (array) {
                                                return Array$Std.map(Json$Std.$$Array.get(array), Json$Std.$$String.get);
                                              }));
                                })));
              }));
}

function getExtends(param) {
  var profile = param[0];
  var triple = List$Std.fromArray(String$Std.split(profile, "-"));
  var arch;
  if (triple) {
    var match = triple.tl;
    if (match) {
      switch (match.hd) {
        case "armv8" :
            arch = {
              TAG: /* Ok */0,
              _0: "armv8"
            };
            break;
        case "wasm" :
        case "x86_64" :
            arch = {
              TAG: /* Ok */0,
              _0: "x86_64"
            };
            break;
        default:
          arch = {
            TAG: /* Error */1,
            _0: "Could not detect image arch for profile: " + profile
          };
      }
    } else {
      arch = {
        TAG: /* Error */1,
        _0: "Could not detect image arch for profile: " + profile
      };
    }
  } else {
    arch = {
      TAG: /* Error */1,
      _0: "Could not detect image arch for profile: " + profile
    };
  }
  var end = param[1] ? "-bootstrap" : "";
  return Result$Std.map(arch, (function (arch) {
                return [".conan" + "-" + arch + end];
              }));
}

function getJob(allInts, buildOrder) {
  var needs = buildOrder[Array$Std.length(buildOrder) - 1 | 0];
  return Array$Std.concat(Array$Std.flatMapWithIndex(buildOrder, (function (index, group) {
                    var groupJobName = "group-job-" + Int$Std.toString(index);
                    var group$1 = buildOrder[index - 1 | 0];
                    var groupJob_1 = {
                      extends: Jobt.$$default.extends,
                      variables: Jobt.$$default.variables,
                      image: Jobt.$$default.image,
                      tags: ["x86_64"],
                      before_script: Jobt.$$default.before_script,
                      script: ["echo"],
                      after_script: Jobt.$$default.after_script,
                      needs: Array$Std.uniq(group$1 !== undefined ? Array$Std.flatMap(group$1, (function (pkg) {
                                    var match = String$Std.split(pkg, "@#");
                                    if (match.length !== 2) {
                                      return [];
                                    }
                                    var pkg$1 = match[0];
                                    if (Array$Std.some(allInts, (function (param) {
                                              var base = param.base;
                                              return base.name + "/" + base.version === pkg$1;
                                            }))) {
                                      return [pkg$1];
                                    } else {
                                      return [];
                                    }
                                  })) : []),
                      services: Jobt.$$default.services,
                      cache: Jobt.$$default.cache,
                      retry: Jobt.$$default.retry,
                      artifacts: Jobt.$$default.artifacts,
                      when: Jobt.$$default.when,
                      allow_failure: Jobt.$$default.allow_failure
                    };
                    var groupJob = [
                      groupJobName,
                      groupJob_1
                    ];
                    return Array$Std.concat(Array$Std.flatMap(group, (function (pkg) {
                                      var match = String$Std.split(pkg, "@#");
                                      var match$1;
                                      if (match.length !== 2) {
                                        match$1 = [
                                          "invalid-pkg",
                                          "invalid-rev"
                                        ];
                                      } else {
                                        var pkg$1 = match[0];
                                        var pkgRevision = match[1];
                                        match$1 = [
                                          pkg$1,
                                          pkgRevision
                                        ];
                                      }
                                      var pkgRevision$1 = match$1[1];
                                      var pkg$2 = match$1[0];
                                      var ints = Array$Std.filter(allInts, (function (param) {
                                              var match = param.base;
                                              if (pkgRevision$1 === param.revision) {
                                                return pkg$2 === match.name + "/" + match.version;
                                              } else {
                                                return false;
                                              }
                                            }));
                                      return Array$Std.map(ints, (function ($$int) {
                                                    var base = $$int.base;
                                                    Console$Std.log("Found conan instance: " + base.name + "/" + base.version + " (" + $$int.profile + ")");
                                                    var image = $$int.base.image;
                                                    var image$1 = image !== undefined ? (Console$Std.log("Conan Mode: Image is set, using it as docker image"), image) : (Console$Std.log("Conan Mode: Image is not set, using default"), undefined);
                                                    return [
                                                            base.name + "/" + base.version,
                                                            {
                                                              extends: $$int.extends,
                                                              variables: Caml_option.some(getVariables($$int)),
                                                              image: image$1,
                                                              tags: Jobt.$$default.tags,
                                                              before_script: Array$Std.concat(["cd $CI_PROJECT_DIR/" + $$int.base.folder], $$int.base.beforeScript),
                                                              script: Jobt.$$default.script,
                                                              after_script: Array$Std.concat(["cd $CI_PROJECT_DIR/" + $$int.base.folder], $$int.base.afterScript),
                                                              needs: Array$Std.concat(base.needs, [groupJobName]),
                                                              services: Jobt.$$default.services,
                                                              cache: Jobt.$$default.cache,
                                                              retry: Jobt.$$default.retry,
                                                              artifacts: Jobt.$$default.artifacts,
                                                              when: Jobt.$$default.when,
                                                              allow_failure: Jobt.$$default.allow_failure
                                                            }
                                                          ];
                                                  }));
                                    })), [groupJob]);
                  })), [[
                "conan-upload",
                {
                  extends: Jobt.$$default.extends,
                  variables: Jobt.$$default.variables,
                  image: Result$Std.toOption(Profile.getImage(Profile.$$default, Caml_option.nullable_to_opt(Deno.env.get("CONAN_DOCKER_REGISTRY")), Caml_option.nullable_to_opt(Deno.env.get("CONAN_DOCKER_PREFIX")))),
                  tags: Result$Std.toOption(Profile.getTags(Profile.$$default)),
                  before_script: Jobt.$$default.before_script,
                  script: Array$Std.concat([
                        "alias c=conan",
                        "c config install $CONAN_CONFIG_URL -sf $CONAN_CONFIG_DIR",
                        "c config set storage.path=$CONAN_DATA_PATH",
                        "c user $CONAN_LOGIN_USERNAME -p $CONAN_LOGIN_PASSWORD -r $CONAN_REPO_INTERNAL",
                        "c user $CONAN_LOGIN_USERNAME -p $CONAN_LOGIN_PASSWORD -r $CONAN_REPO_PUBLIC",
                        "c user $CONAN_LOGIN_USERNAME -p $CONAN_LOGIN_PASSWORD -r $CONAN_REPO_DEV_INTERNAL",
                        "c user $CONAN_LOGIN_USERNAME -p $CONAN_LOGIN_PASSWORD -r $CONAN_REPO_DEV_PUBLIC"
                      ], Array$Std.flatMap(Array$Std.reduce(Array$Std.flat(buildOrder), (function (pkgs, pkg) {
                                  var match = String$Std.split(pkg, "@#");
                                  if (match.length !== 2) {
                                    return pkgs;
                                  }
                                  var pkg$1 = match[0];
                                  var match$1 = String$Std.split(pkg$1, "/");
                                  var match$2 = Array$Std.find(allInts, (function (param) {
                                          var match = param.base;
                                          return String$Std.startsWith(pkg$1, match.name + "/" + match.version);
                                        }));
                                  if (match$1.length !== 2) {
                                    return pkgs;
                                  }
                                  var name = match$1[0];
                                  var version = match$1[1];
                                  if (match$2 !== undefined) {
                                    return Array$Std.concat(pkgs, [[
                                                  name,
                                                  version,
                                                  match$2.repo,
                                                  match$2.repoDev
                                                ]]);
                                  } else {
                                    return pkgs;
                                  }
                                }), []), (function (param) {
                              var repoDev = param[3];
                              var repo = param[2];
                              var version = param[1];
                              var name = param[0];
                              var match = String$Std.match(version, /^[0-9a-f]{40}$/);
                              return Array$Std.concat([
                                          "c download " + name + "/" + version + "@ -r " + repoDev,
                                          "c upload " + name + "/" + version + "@ --all -c -r " + repo
                                        ], match !== undefined ? [
                                            "c download " + name + "/$CI_COMMIT_REF_NAME@ -r " + repoDev,
                                            "c upload " + name + "/$CI_COMMIT_REF_NAME@ --all -c -r " + repo
                                          ] : []);
                            }))),
                  after_script: Jobt.$$default.after_script,
                  needs: needs !== undefined ? Array$Std.map(needs, (function (need) {
                            var match = String$Std.split(need, "@#");
                            if (match.length !== 2) {
                              return "invalid-need";
                            } else {
                              return match[0];
                            }
                          })) : [],
                  services: Jobt.$$default.services,
                  cache: Jobt.$$default.cache,
                  retry: Jobt.$$default.retry,
                  artifacts: Jobt.$$default.artifacts,
                  when: Jobt.$$default.when,
                  allow_failure: Jobt.$$default.allow_failure
                }
              ]]);
}

function getConanInstances($$int) {
  var version = $$int.version;
  var name = $$int.name;
  var repos = getRepos($$int.folder);
  var args = getArgs(name, $$int.modeInt);
  return Task$Std.seq(Array$Std.map($$int.profiles, (function (profile) {
                    var $$extends = getExtends([
                          profile,
                          $$int.bootstrap
                        ]);
                    return Task$Std.flatMap(Task$Std.fromResult(Result$Std.seq2([
                                        $$extends,
                                        repos
                                      ])), (function (param) {
                                  var match = param[1];
                                  var repoDev = match[1];
                                  var repo = match[0];
                                  var $$extends = param[0];
                                  var hash = Hash$Std.hashN([
                                        $$int,
                                        profile
                                      ], 3);
                                  return Task$Std.flatMap(Task$Std.flatMap(Proc$Std.run(Array$Std.concat([
                                                          "conan",
                                                          "lock",
                                                          "create",
                                                          "--ref=" + name + "/" + version,
                                                          "--build=" + name + "/" + version,
                                                          "--lockfile-out=" + name + "-" + version + "-" + hash + ".lock",
                                                          "-pr=" + profile
                                                        ], args)), (function (param) {
                                                    return Task$Std.fromResult(Result$Std.flatMap(File$Std.read(name + "-" + version + "-" + hash + ".lock"), (function (lock) {
                                                                      var ref = Json$Std.$$Object.get(Json$Std.$$Object.get(Json$Std.$$Object.get(Json$Std.$$Object.get(Json$Std.parse(lock), "graph_lock"), "nodes"), "1"), "ref");
                                                                      if (typeof ref !== "number" && ref.TAG === /* String */0) {
                                                                        var revision = String$Std.split(ref._0, "#")[1];
                                                                        if (revision !== undefined) {
                                                                          return {
                                                                                  TAG: /* Ok */0,
                                                                                  _0: revision
                                                                                };
                                                                        } else {
                                                                          return {
                                                                                  TAG: /* Error */1,
                                                                                  _0: "Invalid lock file: " + name + "-" + version + "-" + hash + ".lock"
                                                                                };
                                                                        }
                                                                      }
                                                                      return {
                                                                              TAG: /* Error */1,
                                                                              _0: "Invalid lock file: " + name + "-" + version + "-" + hash + ".lock"
                                                                            };
                                                                    })));
                                                  })), (function (revision) {
                                                return Task$Std.to({
                                                            base: $$int,
                                                            extends: $$extends,
                                                            revision: revision,
                                                            profile: profile,
                                                            repo: repo,
                                                            repoDev: repoDev,
                                                            args: args
                                                          });
                                              }));
                                }));
                  })));
}

function getJobs(ints) {
  var ints$1 = Array$Std.filter(ints, (function ($$int) {
          return $$int.mode === "conan";
        }));
  return Task$Std.flatMap(Task$Std.flatMap(init(ints$1), (function (param) {
                    return Task$Std.map(Task$Std.pool(Array$Std.map(ints$1, (function ($$int, param) {
                                          return getConanInstances($$int);
                                        })), navigator.hardwareConcurrency), Array$Std.flat);
                  })), (function (ints) {
                if (Array$Std.empty(ints)) {
                  return Task$Std.to([]);
                } else {
                  return Task$Std.map(Task$Std.map(getBuildOrder(ints), (function (buildOrder) {
                                    return getJob(ints, buildOrder);
                                  })), (function (jobs) {
                                return Array$Std.concat($$extends, jobs);
                              }));
                }
              }));
}

var hashLength = 3;

export {
  $$extends ,
  hashLength ,
  hashN ,
  getArgs ,
  getRepos ,
  getVariables ,
  init ,
  getBuildOrder ,
  getExtends ,
  getJob ,
  getConanInstances ,
  getJobs ,
  
}
/* extends Not a pure module */
