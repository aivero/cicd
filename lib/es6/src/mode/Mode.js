// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Git from "./Git.js";
import * as Job from "../job/Job.js";
import * as Config from "../Config.js";
import * as Manual from "./Manual.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Proc$Std from "@aivero/std/lib/es6/src/Deno/Proc.js";
import * as Task$Std from "@aivero/std/lib/es6/src/Task.js";
import * as Array$Std from "@aivero/std/lib/es6/src/Array.js";
import * as Result$Std from "@aivero/std/lib/es6/src/Result.js";
import * as String$Std from "@aivero/std/lib/es6/src/String.js";
import * as Console$Std from "@aivero/std/lib/es6/src/Console.js";

function findAllInts(recursive) {
  var cmd = Array$Std.concat([
        "git",
        "ls-files",
        "**devops.yml"
      ], recursive ? ["--recurse-submodules"] : []);
  return Task$Std.flatMap(Proc$Std.run(cmd), (function (e) {
                return Task$Std.fromResult(Result$Std.map(Result$Std.seq(Array$Std.map(String$Std.split(String$Std.trim(e), "\n"), Config.loadFile)), Array$Std.flat));
              }));
}

function findReqs($$int, allInts) {
  return Array$Std.flatMap(allInts, (function (aint) {
                if (!(Array$Std.includes($$int.needs, aint.name) || Array$Std.includes($$int.trigger, aint.name))) {
                  return [];
                }
                var reqs = findReqs(aint, allInts);
                if (Array$Std.some(reqs, (function (req) {
                          return Array$Std.includes(req.needs, aint.name) ? true : Array$Std.includes(req.trigger, aint.name);
                        }))) {
                  return reqs;
                } else {
                  return Array$Std.concat([aint], reqs);
                }
              }));
}

function addReqs(ints, allInts) {
  return Task$Std.flatMap(Task$Std.seq2([
                  ints,
                  allInts
                ]), (function (param) {
                var allInts = param[1];
                var ints = param[0];
                var reqs = Array$Std.flatMap(ints, (function (__x) {
                        return findReqs(__x, allInts);
                      }));
                var ints$1 = Array$Std.concat(Array$Std.filter(reqs, (function (req) {
                            return !Array$Std.some(ints, (function ($$int) {
                                          return $$int.name === req.name;
                                        }));
                          })), ints);
                return Task$Std.to(Array$Std.map(ints$1, (function (triggered) {
                                  var triggers = Array$Std.map(Array$Std.filter(ints$1, (function ($$int) {
                                              return Array$Std.includes($$int.trigger, triggered.name);
                                            })), (function (trigger) {
                                          return trigger.name + "/" + trigger.version;
                                        }));
                                  var newrecord = Caml_obj.caml_obj_dup(triggered);
                                  newrecord.needs = Array$Std.uniq(Array$Std.concat(triggered.needs, triggers));
                                  return newrecord;
                                })));
              }));
}

function load(param) {
  var kind = Deno.env.get("mode");
  var component = Deno.env.get("component");
  var recursive = Deno.env.get("recursive");
  var recursive$1;
  if (recursive == null) {
    recursive$1 = true;
  } else {
    switch (recursive) {
      case "0" :
      case "false" :
          recursive$1 = false;
          break;
      case "1" :
      case "true" :
          recursive$1 = true;
          break;
      default:
        recursive$1 = true;
    }
  }
  var allInts = findAllInts(recursive$1);
  var allInts$1 = Task$Std.map(allInts, (function (ints) {
          if (Array$Std.empty(ints)) {
            Console$Std.log("No instances found");
            return [];
          } else {
            Console$Std.log("All instances:");
            Console$Std.log(Array$Std.join(Array$Std.map(ints, (function ($$int) {
                            return $$int.name;
                          })), ", "));
            return ints;
          }
        }));
  var ints;
  if (kind == null) {
    ints = (component == null) ? Git.findInts(undefined) : Manual.findInts(allInts$1);
  } else {
    switch (kind) {
      case "git" :
          ints = Git.findInts(undefined);
          break;
      case "manual" :
          ints = Manual.findInts(allInts$1);
          break;
      default:
        ints = Task$Std.toError("Mode not supported: " + kind);
    }
  }
  var ints$1 = Task$Std.map(ints, (function (ints) {
          if (Array$Std.empty(ints)) {
            Console$Std.log("Instances selected");
            return [];
          } else {
            return Array$Std.map(ints, (function ($$int) {
                          Console$Std.log("Instance selected: " + $$int.name);
                          return $$int;
                        }));
          }
        }));
  var ints$2 = addReqs(ints$1, allInts$1);
  return Task$Std.flatMap(ints$2, Job.load);
}

export {
  findAllInts ,
  findReqs ,
  addReqs ,
  load ,
  
}
/* Git Not a pure module */
