// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Git from "./Git.js";
import * as Job from "../job/Job.js";
import * as Proc from "../std/Proc.js";
import * as Task from "../std/Task.js";
import * as $$Array from "../std/Array.js";
import * as Config from "../Config.js";
import * as Manual from "./Manual.js";
import * as Result from "../std/Result.js";
import * as $$String from "../std/String.js";
import * as TaskResult from "../std/TaskResult.js";

function findAllInts(recursive) {
  var cmd = $$Array.concat([
        "git",
        "ls-files",
        "**devops.yml"
      ], recursive ? ["--recurse-submodules"] : []);
  return TaskResult.flatMap(Proc.run(cmd), (function (e) {
                return Task.resolve(Result.map(Result.seq($$Array.map($$String.split($$String.trim(e), "\n"), Config.loadFile)), $$Array.flatten));
              }));
}

function findReqs($$int, allInts) {
  return $$Array.flatMap(allInts, (function (aint) {
                if ($$Array.includes($$int.reqs, aint.name) || $$Array.includes($$int.trigger, aint.name)) {
                  return $$Array.concat([aint], findReqs(aint, allInts));
                } else {
                  return [];
                }
              }));
}

function addReqs(ints, allInts) {
  return TaskResult.flatMap(TaskResult.seq2([
                  ints,
                  allInts
                ]), (function (param) {
                var allInts = param[1];
                var ints = param[0];
                var ints$1 = $$Array.concat($$Array.flatMap(ints, (function (__x) {
                            return findReqs(__x, allInts);
                          })), ints);
                return TaskResult.resolve($$Array.map(ints$1, (function (triggered) {
                                  var triggers = $$Array.map($$Array.filter(ints$1, (function ($$int) {
                                              return $$Array.includes($$int.trigger, triggered.name);
                                            })), (function (trigger) {
                                          return trigger.name;
                                        }));
                                  return {
                                          name: triggered.name,
                                          version: triggered.version,
                                          folder: triggered.folder,
                                          mode: triggered.mode,
                                          modeInt: triggered.modeInt,
                                          commit: triggered.commit,
                                          branch: triggered.branch,
                                          reqs: $$Array.concat(triggered.reqs, triggers),
                                          trigger: triggered.trigger,
                                          bootstrap: triggered.bootstrap,
                                          profiles: triggered.profiles,
                                          cmdsPre: triggered.cmdsPre,
                                          cmds: triggered.cmds,
                                          cmdsPost: triggered.cmdsPost,
                                          image: triggered.image,
                                          tags: triggered.tags
                                        };
                                })));
              }));
}

function load(param) {
  var kind = Deno.env.get("mode");
  var recursive = Deno.env.get("recursive");
  var source = Deno.env.get("CI_PIPELINE_SOURCE");
  var recursive$1;
  if (recursive == null) {
    recursive$1 = true;
  } else {
    switch (recursive) {
      case "0" :
      case "false" :
          recursive$1 = false;
          break;
      case "1" :
      case "true" :
          recursive$1 = true;
          break;
      default:
        recursive$1 = true;
    }
  }
  var allInts = findAllInts(recursive$1);
  var ints;
  if (kind == null) {
    ints = (source == null) || source !== "web" ? Git.findInts(undefined) : Manual.findInts(allInts);
  } else {
    switch (kind) {
      case "git" :
          ints = Git.findInts(undefined);
          break;
      case "manual" :
          ints = Manual.findInts(allInts);
          break;
      default:
        ints = Task.resolve({
              TAG: /* Error */1,
              _0: "Mode not supported: " + kind
            });
    }
  }
  var ints$1 = addReqs(ints, allInts);
  return TaskResult.flatMap(ints$1, Job.load);
}

export {
  findAllInts ,
  findReqs ,
  addReqs ,
  load ,
  
}
/* Git Not a pure module */
