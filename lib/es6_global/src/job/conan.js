// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Fs from "fs";
import * as $$File from "../std/file.js";
import * as Flat from "../std/flat.js";
import * as Proc from "../std/proc.js";
import * as Task from "../std/task.js";
import * as Path from "path";
import * as Detect from "../detect.js";
import * as Js_dict from "../../../../node_modules/rescript/lib/es6/js_dict.js";
import * as Belt_Array from "../../../../node_modules/rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "../../../../node_modules/rescript/lib/es6/belt_Option.js";
import * as Belt_Result from "../../../../node_modules/rescript/lib/es6/belt_Result.js";
import * as Caml_option from "../../../../node_modules/rescript/lib/es6/caml_option.js";

function getArgs($$int) {
  var args = Deno.env.get("args");
  var args$1 = (args == null) ? [] : args.split(" ");
  var match = $$int.name;
  var match$1 = $$int.settings;
  var sets = match !== undefined ? (
      match$1 !== undefined ? Belt_Array.map(Belt_Array.map(Js_dict.entries(Caml_option.valFromOption(match$1)), (function (param) {
                    var val = param[1];
                    return [
                            param[0],
                            val.toString() === "true" ? "True" : (
                                val.toString() === "false" ? "False" : val
                              )
                          ];
                  })), (function (param) {
                return "-s " + match + ":" + param[0] + "=" + param[1];
              })) : []
    ) : [];
  var match$2 = $$int.name;
  var match$3 = $$int.options;
  var opts = match$2 !== undefined ? (
      match$3 !== undefined ? Belt_Array.map(Belt_Array.map(Js_dict.entries(Caml_option.valFromOption(match$3)), (function (param) {
                    var val = param[1];
                    return [
                            param[0],
                            val.toString() === "true" ? "True" : (
                                val.toString() === "false" ? "False" : val
                              )
                          ];
                  })), (function (param) {
                return "-o " + match$2 + ":" + param[0] + "=" + param[1];
              })) : []
    ) : [];
  return Belt_Array.concatMany([
              args$1,
              sets,
              opts
            ]);
}

function getRepo($$int) {
  return Belt_Result.map($$File.read(Path.join(Belt_Option.getExn($$int.folder), "conanfile.py")), (function (content) {
                content.includes("Proprietary");
                return "$CONAN_REPO_INTERNAL";
              }));
}

function getCmds(param) {
  var $$int = param.int;
  var initCmds = [
    "conan config install $CONAN_CONFIG_URL -sf $CONAN_CONFIG_DIR",
    "conan user $CONAN_LOGIN_USERNAME -p $CONAN_LOGIN_PASSWORD -r $CONAN_REPO_ALL",
    "conan user $CONAN_LOGIN_USERNAME -p $CONAN_LOGIN_PASSWORD -r $CONAN_REPO_INTERNAL",
    "conan user $CONAN_LOGIN_USERNAME -p $CONAN_LOGIN_PASSWORD -r $CONAN_REPO_PUBLIC",
    "conan config set general.default_profile=" + param.profile
  ];
  var repo = getRepo($$int);
  var args = Belt_Array.joinWith(getArgs($$int), " ", (function (str) {
          return str;
        }));
  var match = $$int.name;
  var match$1 = $$int.version;
  var match$2 = $$int.folder;
  var cmds;
  if (match !== undefined) {
    if (match$1 !== undefined) {
      if (match$2 !== undefined) {
        if (repo.TAG === /* Ok */0) {
          var repo$1 = repo._0;
          var createPkg = ["conan create " + args + match$2 + " " + match + "/" + match$1 + "@"];
          var createDbg = ["conan create " + args + match$2 + " " + match + "-dbg/" + match$1 + "@"];
          var uploadPkg = ["conan upload " + match + "/" + match$1 + "@ --all -c -r " + repo$1];
          var match$3 = $$int.debugPkg;
          var uploadDbg = match$3 !== undefined ? (
              match$3 ? ["conan upload " + match + "-dbg/" + match$1 + "@ --all -c -r " + repo$1] : []
            ) : [];
          cmds = Belt_Array.concatMany([
                createPkg,
                createDbg,
                uploadPkg,
                uploadDbg
              ]);
        } else {
          cmds = [];
        }
      } else {
        cmds = [];
      }
    } else {
      cmds = [];
    }
  } else {
    cmds = [];
  }
  return Belt_Array.concatMany([
              initCmds,
              cmds,
              [
                "conan remove --locks",
                "conan remove * -f"
              ]
            ]);
}

function getInfo(param) {
  var mode = param.mode;
  var profile = param.profile;
  var $$int = param.int;
  var match = $$int.name;
  var match$1 = $$int.version;
  if (match !== undefined && match$1 !== undefined) {
    return Task.map(Proc.run(Belt_Array.concatMany([
                        [
                          "conan",
                          "info",
                          "-j",
                          match + "-" + match$1 + "-" + profile + ".json",
                          "-pr=" + profile
                        ],
                        getArgs($$int),
                        [match + "/" + match$1 + "@"]
                      ])), (function (res) {
                  return Belt_Result.flatMap(res, (function (param) {
                                var output = $$File.read(match + "-" + match$1 + "-" + profile + ".json");
                                if (output.TAG !== /* Ok */0) {
                                  return {
                                          TAG: /* Error */1,
                                          _0: output._0
                                        };
                                }
                                var find = JSON.parse(output._0).find(function (e) {
                                      return e.reference === match + "/" + match$1;
                                    });
                                if (find !== undefined) {
                                  return {
                                          TAG: /* Ok */0,
                                          _0: {
                                            info: find === undefined ? undefined : Caml_option.some(find),
                                            int: $$int,
                                            profile: profile,
                                            mode: mode
                                          }
                                        };
                                } else {
                                  return {
                                          TAG: /* Error */1,
                                          _0: "Couldn't find info for: " + match + "/" + match$1 + " (" + profile + ")"
                                        };
                                }
                              }));
                }));
  } else {
    return Task.resolve({
                TAG: /* Error */1,
                _0: "Name or version not defined"
              });
  }
}

function exportPkg($$int) {
  var match = $$int.name;
  var match$1 = $$int.version;
  var match$2 = $$int.folder;
  if (match !== undefined && match$1 !== undefined && match$2 !== undefined) {
    return Proc.run([
                "conan",
                "export",
                match$2,
                match + "/" + match$1 + "@"
              ]);
  } else {
    return Task.resolve({
                TAG: /* Error */1,
                _0: "Name, version or folder not defined"
              });
  }
}

function getLockFile(pkgInfos) {
  return Task.map(Flat.task(Task.map(Flat.task(Task.map(Flat.task(Task.map(pkgInfos, (function (res) {
                                        return Belt_Result.map(res, (function (pkgInfos) {
                                                      return Task.map(Promise.all(Belt_Array.map(pkgInfos, (function (pkgInfo) {
                                                                            var match = pkgInfo.int.name;
                                                                            var match$1 = pkgInfo.int.version;
                                                                            if (match !== undefined && match$1 !== undefined) {
                                                                              return Task.map(Proc.run(Belt_Array.concat([
                                                                                                  "conan",
                                                                                                  "lock",
                                                                                                  "create",
                                                                                                  "--ref=" + match + "/" + match$1,
                                                                                                  "--lockfile-out=" + match + "-" + match$1 + "-" + pkgInfo.info.revision + ".lock",
                                                                                                  "-pr=" + pkgInfo.profile
                                                                                                ], getArgs(pkgInfo.int))), (function (output) {
                                                                                            if (output.TAG === /* Ok */0) {
                                                                                              return {
                                                                                                      TAG: /* Ok */0,
                                                                                                      _0: pkgInfo
                                                                                                    };
                                                                                            } else {
                                                                                              return {
                                                                                                      TAG: /* Error */1,
                                                                                                      _0: output._0
                                                                                                    };
                                                                                            }
                                                                                          }));
                                                                            } else {
                                                                              return Task.resolve({
                                                                                          TAG: /* Error */1,
                                                                                          _0: "This should not happen"
                                                                                        });
                                                                            }
                                                                          }))), Flat.array);
                                                    }));
                                      }))), (function (res) {
                                return Belt_Result.map(res, (function (pkgInfos) {
                                              var locks = Belt_Array.map(pkgInfos, (function (pkgInfo) {
                                                      var match = pkgInfo.int.name;
                                                      var match$1 = pkgInfo.int.version;
                                                      if (match !== undefined && match$1 !== undefined) {
                                                        return match + "-" + match$1 + "-" + pkgInfo.info.revision + ".lock";
                                                      } else {
                                                        return "";
                                                      }
                                                    }));
                                              if (locks.length !== 0) {
                                                return Task.map(Proc.run(Belt_Array.concat([
                                                                    "conan",
                                                                    "lock",
                                                                    "bundle",
                                                                    "create",
                                                                    "--bundle-out=lock.bundle"
                                                                  ], locks)), (function (output) {
                                                              if (output.TAG === /* Ok */0) {
                                                                return {
                                                                        TAG: /* Ok */0,
                                                                        _0: pkgInfos
                                                                      };
                                                              } else {
                                                                return {
                                                                        TAG: /* Error */1,
                                                                        _0: output._0
                                                                      };
                                                              }
                                                            }));
                                              } else {
                                                return Task.resolve({
                                                            TAG: /* Ok */0,
                                                            _0: pkgInfos
                                                          });
                                              }
                                            }));
                              }))), (function (res) {
                        return Belt_Result.map(res, (function (param) {
                                      if (Fs.existsSync("build_order.json")) {
                                        return Task.map(Proc.run([
                                                        "conan",
                                                        "lock",
                                                        "bundle",
                                                        "build-order",
                                                        "lock.bundle",
                                                        "--json=build_order.json"
                                                      ]), (function (output) {
                                                      if (output.TAG === /* Ok */0) {
                                                        return res;
                                                      } else {
                                                        return {
                                                                TAG: /* Error */1,
                                                                _0: output._0
                                                              };
                                                      }
                                                    }));
                                      } else {
                                        return Task.resolve(res);
                                      }
                                    }));
                      }))), (function (res) {
                return Belt_Result.flatMap(res, (function (param) {
                              if (Fs.existsSync("build_order.json")) {
                                return Belt_Result.map($$File.read("build_order.json"), (function (content) {
                                              return JSON.parse(content);
                                            }));
                              } else {
                                return {
                                        TAG: /* Ok */0,
                                        _0: []
                                      };
                              }
                            }));
              }));
}

function getJob(buildOrder, pkgInfos) {
  return Belt_Result.map(Flat.array(Belt_Array.mapWithIndex(buildOrder, (function (index, group) {
                        return Flat.array(Belt_Array.map(group, (function (pkg) {
                                          var revision = Belt_Array.get(pkg.split("#"), 1);
                                          var foundPkg = pkgInfos.find(function (e) {
                                                if (revision !== undefined) {
                                                  return revision === e.info.revision;
                                                } else {
                                                  return false;
                                                }
                                              });
                                          if (foundPkg === undefined) {
                                            return {
                                                    TAG: /* Error */1,
                                                    _0: "Couldn't find package: " + pkg
                                                  };
                                          }
                                          var mode = foundPkg.mode;
                                          var profile = foundPkg.profile;
                                          var $$int = foundPkg.int;
                                          var image = Detect.getImage({
                                                int: $$int,
                                                profile: profile,
                                                mode: mode
                                              });
                                          if (image.TAG !== /* Ok */0) {
                                            return {
                                                    TAG: /* Error */1,
                                                    _0: image._0
                                                  };
                                          }
                                          var needs = $$int.needs;
                                          var group = Belt_Array.get(buildOrder, index - 1 | 0);
                                          return {
                                                  TAG: /* Ok */0,
                                                  _0: {
                                                    name: pkg,
                                                    image: image._0,
                                                    script: getCmds({
                                                          int: $$int,
                                                          profile: profile,
                                                          mode: mode
                                                        }),
                                                    needs: Belt_Array.concat(needs !== undefined ? needs : [], group !== undefined ? group : [])
                                                  }
                                                };
                                        })));
                      }))), Belt_Array.concatMany);
}

function getJobs(zips) {
  var zips$1 = zips.filter(function (zip) {
        return zip.mode === "conan";
      });
  var pkgInfos = Task.flatMap(Promise.all(Belt_Array.map(zips$1, (function (zip) {
                  return exportPkg(zip.int);
                }))), (function (param) {
          return Task.map(Promise.all(Belt_Array.map(zips$1, getInfo)), Flat.array);
        }));
  var lockfile = getLockFile(pkgInfos);
  return Task.map(Promise.all([
                  pkgInfos,
                  lockfile
                ]), (function (param) {
                var lockfile = param[1];
                var pkgInfos = param[0];
                if (pkgInfos.TAG === /* Ok */0) {
                  if (lockfile.TAG === /* Ok */0) {
                    return getJob(lockfile._0, pkgInfos._0);
                  } else {
                    return {
                            TAG: /* Error */1,
                            _0: lockfile._0
                          };
                  }
                } else {
                  return {
                          TAG: /* Error */1,
                          _0: pkgInfos._0
                        };
                }
              }));
}

export {
  getArgs ,
  getRepo ,
  getCmds ,
  getInfo ,
  exportPkg ,
  getLockFile ,
  getJob ,
  getJobs ,
  
}
/* fs Not a pure module */
