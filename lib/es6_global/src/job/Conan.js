// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Fs from "fs";
import * as Seq from "../std/Seq.js";
import * as $$File from "../std/File.js";
import * as Flat from "../std/Flat.js";
import * as Hash from "../std/Hash.js";
import * as Proc from "../std/Proc.js";
import * as Task from "../std/Task.js";
import * as Path from "path";
import * as Detect from "../Detect.js";
import * as $$String from "../../../../node_modules/rescript/lib/es6/string.js";
import * as Js_dict from "../../../../node_modules/rescript/lib/es6/js_dict.js";
import * as Caml_obj from "../../../../node_modules/rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "../../../../node_modules/rescript/lib/es6/belt_Array.js";
import * as TaskResult from "../std/TaskResult.js";
import * as Belt_Option from "../../../../node_modules/rescript/lib/es6/belt_Option.js";
import * as Belt_Result from "../../../../node_modules/rescript/lib/es6/belt_Result.js";
import * as Caml_option from "../../../../node_modules/rescript/lib/es6/caml_option.js";

function hashN(__x) {
  return Hash.hashN(__x, 3);
}

function getArgs($$int) {
  var args = Deno.env.get("args");
  var args$1 = (args == null) ? [] : args.split(" ");
  var match = Seq.option2($$int.name, $$int.settings);
  var sets;
  if (match !== undefined) {
    var name = match[0];
    sets = Belt_Array.map(Belt_Array.map(Js_dict.entries(match[1]), (function (param) {
                var val = param[1];
                return [
                        param[0],
                        val.toString() === "true" ? "True" : (
                            val.toString() === "false" ? "False" : val
                          )
                      ];
              })), (function (param) {
            return "-s " + name + ":" + param[0] + "=" + param[1];
          }));
  } else {
    sets = [];
  }
  var match$1 = Seq.option2($$int.name, $$int.options);
  var opts;
  if (match$1 !== undefined) {
    var name$1 = match$1[0];
    opts = Belt_Array.map(Belt_Array.map(Js_dict.entries(match$1[1]), (function (param) {
                var val = param[1];
                return [
                        param[0],
                        val.toString() === "true" ? "True" : (
                            val.toString() === "false" ? "False" : val
                          )
                      ];
              })), (function (param) {
            return "-o " + name$1 + ":" + param[0] + "=" + param[1];
          }));
  } else {
    opts = [];
  }
  return Flat.array([
              args$1,
              sets,
              opts
            ]);
}

function getRepo($$int) {
  return Belt_Result.map($$File.read(Path.join(Belt_Option.getExn($$int.folder), "conanfile.py")), (function (content) {
                if (content.includes("Proprietary")) {
                  return "$CONAN_REPO_INTERNAL";
                } else {
                  return "$CONAN_REPO_PUBLIC";
                }
              }));
}

function getVariables(param) {
  var profile = param.profile;
  var $$int = param.int;
  return Belt_Result.map(getRepo($$int), (function (repo) {
                var match = Seq.option([
                      $$int.name,
                      $$int.version,
                      $$int.folder
                    ]);
                if (match === undefined) {
                  return [];
                }
                if (match.length !== 3) {
                  return [];
                }
                var name = match[0];
                var version = match[1];
                var folder = match[2];
                var match$1 = version.match(/^[0-9a-f]{40}$/);
                return Belt_Array.concat(Belt_Array.concat([
                                [
                                  "NAME",
                                  name
                                ],
                                [
                                  "VERSION",
                                  version
                                ],
                                [
                                  "FOLDER",
                                  folder
                                ],
                                [
                                  "REPO",
                                  repo
                                ],
                                [
                                  "PROFILE",
                                  profile
                                ]
                              ], getArgs($$int).length !== 0 ? [[
                                    "ARGS",
                                    Belt_Array.joinWith(getArgs($$int), " ", (function (str) {
                                            return str;
                                          }))
                                  ]] : []), match$1 !== null ? [[
                                "UPLOAD_ALIAS",
                                "1"
                              ]] : []);
              }));
}

function getCmds(param) {
  var $$int = param.int;
  var initCmds = [
    "conan config install $CONAN_CONFIG_URL -sf $CONAN_CONFIG_DIR",
    "conan user $CONAN_LOGIN_USERNAME -p $CONAN_LOGIN_PASSWORD -r $CONAN_REPO_ALL",
    "conan user $CONAN_LOGIN_USERNAME -p $CONAN_LOGIN_PASSWORD -r $CONAN_REPO_INTERNAL",
    "conan user $CONAN_LOGIN_USERNAME -p $CONAN_LOGIN_PASSWORD -r $CONAN_REPO_PUBLIC",
    "conan config set general.default_profile=" + param.profile
  ];
  var repo = getRepo($$int);
  var args = getArgs($$int);
  var match = Seq.option([
        $$int.name,
        $$int.version,
        $$int.folder
      ]);
  var cmds;
  if (match !== undefined) {
    if (match.length !== 3) {
      cmds = [];
    } else {
      var name = match[0];
      var version = match[1];
      var folder = match[2];
      if (repo.TAG === /* Ok */0) {
        var repo$1 = repo._0;
        var createPkg = [Belt_Array.joinWith([
                  "conan",
                  "create",
                  "-u",
                  folder,
                  name + "/" + version + "@"
                ].concat(args), " ", (function (str) {
                  return str;
                }))];
        var createDbg = [Belt_Array.joinWith([
                  "conan",
                  "create",
                  folder,
                  name + "-dbg/" + version + "@"
                ].concat(args), " ", (function (str) {
                  return str;
                }))];
        var uploadPkg = [Belt_Array.joinWith([
                "conan",
                "upload",
                name + "/" + version + "@",
                "--all",
                "-c",
                "-r",
                repo$1
              ], " ", (function (str) {
                  return str;
                }))];
        var match$1 = Seq.option2(Caml_option.nullable_to_opt(Deno.env.get("CI_COMMIT_REF_NAME")), Caml_option.null_to_opt(version.match(/^[0-9a-f]{40}$/)));
        var uploadPkgAlias = match$1 !== undefined ? [Belt_Array.joinWith([
                  "conan",
                  "upload",
                  name + "/" + match$1[0] + "@",
                  "--all",
                  "-c",
                  "-r",
                  repo$1
                ], " ", (function (str) {
                    return str;
                  }))] : [];
        var match$2 = $$int.debugPkg;
        var uploadDbg = match$2 !== undefined ? (
            match$2 ? [Belt_Array.joinWith([
                      "conan",
                      "upload",
                      name + "-dbg/" + version + "@",
                      "--all",
                      "-c",
                      "-r",
                      repo$1
                    ], " ", (function (str) {
                        return str;
                      }))] : []
          ) : [];
        cmds = Flat.array([
              createPkg,
              createDbg,
              uploadPkg,
              uploadPkgAlias,
              uploadDbg
            ]);
      } else {
        cmds = [];
      }
    }
  } else {
    cmds = [];
  }
  return Flat.array([
              initCmds,
              cmds
            ]);
}

function getInfo(param) {
  var mode = param.mode;
  var profile = param.profile;
  var $$int = param.int;
  var match = Seq.option2($$int.name, $$int.version);
  if (match === undefined) {
    return Task.resolve({
                TAG: /* Error */1,
                _0: "Name or version not defined"
              });
  }
  var version = match[1];
  var name = match[0];
  var hash = Hash.hashN({
        int: $$int,
        profile: profile,
        mode: mode
      }, 3);
  return TaskResult.flatMap(Proc.run(Flat.array([
                      [
                        "conan",
                        "info",
                        "-j",
                        name + "-" + version + "-" + hash + ".json",
                        "-pr=" + profile
                      ],
                      getArgs($$int),
                      [name + "/" + version + "@"]
                    ])), (function (param) {
                return Belt_Result.flatMap($$File.read(name + "-" + version + "-" + hash + ".json"), (function (output) {
                              var find = JSON.parse(output).find(function (e) {
                                    return e.reference === name + "/" + version;
                                  });
                              if (find !== undefined) {
                                return {
                                        TAG: /* Ok */0,
                                        _0: {
                                          info: find === undefined ? undefined : Caml_option.some(find),
                                          int: $$int,
                                          profile: profile,
                                          mode: mode,
                                          hash: hash
                                        }
                                      };
                              } else {
                                return {
                                        TAG: /* Error */1,
                                        _0: "Couldn't find info for: " + name + "/" + version + " (" + profile + ")"
                                      };
                              }
                            }));
              }));
}

function init(zips) {
  var match = Seq.option2(Caml_option.nullable_to_opt(Deno.env.get("CONAN_CONFIG_URL")), Caml_option.nullable_to_opt(Deno.env.get("CONAN_CONFIG_DIR")));
  var match$1 = match !== undefined ? [
      match[0],
      match[1]
    ] : [
      "",
      ""
    ];
  var config = Proc.run([
        "conan",
        "config",
        "install",
        match$1[0],
        "-sf",
        match$1[1]
      ]);
  var exportPkgs = zips.reduce((function (a, zip) {
          var match = Seq.option([
                zip.int.name,
                zip.int.version,
                zip.int.folder
              ]);
          if (match === undefined) {
            return a;
          }
          if (match.length !== 3) {
            return a;
          }
          var name = match[0];
          var version = match[1];
          var folder = match[2];
          if (Belt_Array.some(a, (function (e) {
                    return Caml_obj.caml_equal(e, [
                                name + "/" + version + "@",
                                folder
                              ]);
                  }))) {
            return a;
          } else {
            return Belt_Array.concat(a, [[
                          name + "/" + version + "@",
                          folder
                        ]]);
          }
        }), []);
  return TaskResult.flatten(TaskResult.map(Task.flatMap(config, (function (param) {
                        var match = Seq.option([
                              Caml_option.nullable_to_opt(Deno.env.get("CONAN_LOGIN_USERNAME")),
                              Caml_option.nullable_to_opt(Deno.env.get("CONAN_LOGIN_PASSWORD")),
                              Caml_option.nullable_to_opt(Deno.env.get("CONAN_REPO_INTERNAL"))
                            ]);
                        if (match === undefined) {
                          return Task.resolve({
                                      TAG: /* Ok */0,
                                      _0: ""
                                    });
                        }
                        if (match.length !== 3) {
                          return Task.resolve({
                                      TAG: /* Ok */0,
                                      _0: ""
                                    });
                        }
                        var user = match[0];
                        var passwd = match[1];
                        var repo = match[2];
                        return Proc.run([
                                    "conan",
                                    "user",
                                    user,
                                    "-p",
                                    passwd,
                                    "-r",
                                    repo
                                  ]);
                      })), (function (param) {
                    return TaskResult.pool(Belt_Array.map(exportPkgs, (function (param, param$1) {
                                      return Proc.run([
                                                  "conan",
                                                  "export",
                                                  param[1],
                                                  param[0]
                                                ]);
                                    })), navigator.hardwareConcurrency);
                  })));
}

function getLockFile(pkgInfos) {
  return TaskResult.flatMap(TaskResult.flatten(TaskResult.map(TaskResult.flatten(TaskResult.map(TaskResult.flatten(TaskResult.map(pkgInfos, (function (pkgInfos) {
                                        return TaskResult.pool(Belt_Array.map(pkgInfos, (function (pkgInfo, param) {
                                                          var match = Seq.option2(pkgInfo.int.name, pkgInfo.int.version);
                                                          if (match === undefined) {
                                                            return Task.resolve({
                                                                        TAG: /* Error */1,
                                                                        _0: "This should not happen"
                                                                      });
                                                          }
                                                          var version = match[1];
                                                          var name = match[0];
                                                          return TaskResult.map(Proc.run(Belt_Array.concat([
                                                                              "conan",
                                                                              "lock",
                                                                              "create",
                                                                              "--ref=" + name + "/" + version,
                                                                              "--build=" + name + "/" + version,
                                                                              "--lockfile-out=" + name + "-" + version + "-" + Hash.hashN(pkgInfo, 3) + ".lock",
                                                                              "-pr=" + pkgInfo.profile
                                                                            ], getArgs(pkgInfo.int))), (function (param) {
                                                                        return pkgInfo;
                                                                      }));
                                                        })), navigator.hardwareConcurrency);
                                      }))), (function (pkgInfos) {
                                var locks = Belt_Array.map(pkgInfos, (function (pkgInfo) {
                                        var match = Seq.option2(pkgInfo.int.name, pkgInfo.int.version);
                                        if (match !== undefined) {
                                          return match[0] + "-" + match[1] + "-" + Hash.hashN(pkgInfo, 3) + ".lock";
                                        } else {
                                          return "";
                                        }
                                      }));
                                console.log(locks);
                                if (locks.length !== 0) {
                                  return TaskResult.map(Proc.run(Belt_Array.concat([
                                                      "conan",
                                                      "lock",
                                                      "bundle",
                                                      "create",
                                                      "--bundle-out=lock.bundle"
                                                    ], locks)), (function (param) {
                                                return pkgInfos;
                                              }));
                                } else {
                                  return Task.resolve({
                                              TAG: /* Ok */0,
                                              _0: pkgInfos
                                            });
                                }
                              }))), (function (param) {
                        if (Fs.existsSync("lock.bundle")) {
                          return Proc.run([
                                      "conan",
                                      "lock",
                                      "bundle",
                                      "build-order",
                                      "lock.bundle",
                                      "--json=build_order.json"
                                    ]);
                        } else {
                          return Task.resolve({
                                      TAG: /* Ok */0,
                                      _0: ""
                                    });
                        }
                      }))), (function (param) {
                if (Fs.existsSync("build_order.json")) {
                  return Belt_Result.map($$File.read("build_order.json"), (function (content) {
                                return JSON.parse(content);
                              }));
                } else {
                  return {
                          TAG: /* Ok */0,
                          _0: []
                        };
                }
              }));
}

function getJob(buildOrder, pkgInfos) {
  return Belt_Result.map(Seq.result(Belt_Array.mapWithIndex(buildOrder, (function (index, group) {
                        return Belt_Result.map(Seq.result(Belt_Array.map(group, (function (pkg) {
                                              var match = pkg.split("#");
                                              if (match.length !== 2) {
                                                throw {
                                                      RE_EXN_ID: "Match_failure",
                                                      _1: [
                                                        "Conan.res",
                                                        285,
                                                        10
                                                      ],
                                                      Error: new Error()
                                                    };
                                              }
                                              var pkg$1 = match[0];
                                              var revision = match[1];
                                              var foundPkgs = pkgInfos.filter(function (e) {
                                                    if (revision === e.info.revision) {
                                                      return pkg$1 === e.info.reference + "@";
                                                    } else {
                                                      return false;
                                                    }
                                                  });
                                              return Seq.result(Belt_Array.concat(Belt_Array.map(foundPkgs, (function (foundPkg) {
                                                                    var hash = foundPkg.hash;
                                                                    var mode = foundPkg.mode;
                                                                    var profile = foundPkg.profile;
                                                                    var $$int = foundPkg.int;
                                                                    return Belt_Result.flatMap(Detect.getExtends({
                                                                                    int: $$int,
                                                                                    profile: profile,
                                                                                    mode: mode
                                                                                  }), (function ($$extends) {
                                                                                  return Belt_Result.map(getVariables({
                                                                                                  int: $$int,
                                                                                                  profile: profile,
                                                                                                  mode: mode
                                                                                                }), (function (variables) {
                                                                                                var needs = $$int.req;
                                                                                                var group = Belt_Array.get(buildOrder, index - 1 | 0);
                                                                                                return {
                                                                                                        name: Belt_Option.getExn($$int.name) + "/" + Belt_Option.getExn($$int.version) + "@" + hash,
                                                                                                        extends: $$extends,
                                                                                                        variables: Caml_option.some(Js_dict.fromArray(variables)),
                                                                                                        image: undefined,
                                                                                                        tags: undefined,
                                                                                                        script: undefined,
                                                                                                        needs: Belt_Array.concat(needs !== undefined ? needs : [], group !== undefined ? Belt_Array.map(group, (function (pkg) {
                                                                                                                      var match = pkg.split("#");
                                                                                                                      if (match.length !== 2) {
                                                                                                                        throw {
                                                                                                                              RE_EXN_ID: "Match_failure",
                                                                                                                              _1: [
                                                                                                                                "Conan.res",
                                                                                                                                312,
                                                                                                                                22
                                                                                                                              ],
                                                                                                                              Error: new Error()
                                                                                                                            };
                                                                                                                      }
                                                                                                                      var pkg$1 = match[0];
                                                                                                                      var ver = match[1];
                                                                                                                      return pkg$1 + "#" + $$String.sub(ver, 0, 3);
                                                                                                                    })) : [])
                                                                                                      };
                                                                                              }));
                                                                                }));
                                                                  })), [{
                                                                TAG: /* Ok */0,
                                                                _0: {
                                                                  name: pkg$1 + "#" + $$String.sub(revision, 0, 3),
                                                                  extends: undefined,
                                                                  variables: undefined,
                                                                  image: undefined,
                                                                  tags: ["x86_64"],
                                                                  script: ["echo"],
                                                                  needs: Belt_Array.map(foundPkgs, (function (foundPkg) {
                                                                          return pkg$1 + foundPkg.hash;
                                                                        }))
                                                                }
                                                              }]));
                                            }))), Flat.array);
                      }))), Flat.array);
}

function getJobs(zips) {
  var zips$1 = zips.filter(function (zip) {
        return zip.mode === "conan";
      });
  var pkgInfos = TaskResult.flatten(TaskResult.map(init(zips$1), (function (param) {
              return TaskResult.pool(Belt_Array.map(zips$1, (function (zip, param) {
                                return getInfo(zip);
                              })), navigator.hardwareConcurrency);
            })));
  var lockfile = getLockFile(pkgInfos);
  return Task.map(Promise.all([
                  pkgInfos,
                  lockfile
                ]), (function (param) {
                var lockfile = param[1];
                var pkgInfos = param[0];
                if (pkgInfos.TAG === /* Ok */0) {
                  if (lockfile.TAG === /* Ok */0) {
                    return getJob(lockfile._0, pkgInfos._0);
                  } else {
                    return {
                            TAG: /* Error */1,
                            _0: lockfile._0
                          };
                  }
                } else {
                  return {
                          TAG: /* Error */1,
                          _0: pkgInfos._0
                        };
                }
              }));
}

var hashLength = 3;

export {
  hashLength ,
  hashN ,
  getArgs ,
  getRepo ,
  getVariables ,
  getCmds ,
  getInfo ,
  init ,
  getLockFile ,
  getJob ,
  getJobs ,
  
}
/* fs Not a pure module */
