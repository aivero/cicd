// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Seq from "../std/Seq.js";
import * as $$File from "../std/File.js";
import * as Flat from "../std/Flat.js";
import * as Hash from "../std/Hash.js";
import * as Json from "../std/Json.js";
import * as Proc from "../std/Proc.js";
import * as Task from "../std/Task.js";
import * as Yaml from "../std/Yaml.js";
import * as Path from "path";
import * as $$String from "../../../../node_modules/rescript/lib/es6/string.js";
import * as Js_dict from "../../../../node_modules/rescript/lib/es6/js_dict.js";
import * as Caml_obj from "../../../../node_modules/rescript/lib/es6/caml_obj.js";
import * as Belt_List from "../../../../node_modules/rescript/lib/es6/belt_List.js";
import * as Belt_Array from "../../../../node_modules/rescript/lib/es6/belt_Array.js";
import * as TaskResult from "../std/TaskResult.js";
import * as Belt_Result from "../../../../node_modules/rescript/lib/es6/belt_Result.js";
import * as Caml_option from "../../../../node_modules/rescript/lib/es6/caml_option.js";

function hashN(__x) {
  return Hash.hashN(__x, 3);
}

function getArgs(name, $$int) {
  var args = Deno.env.get("args");
  var args$1 = (args == null) ? [] : args.split(" ");
  var sets = Yaml.get($$int, "settings");
  var tmp;
  tmp = typeof sets === "number" ? [] : (
      sets.TAG === /* Object */2 ? Belt_Array.map(Js_dict.entries(sets._0), (function (param) {
                var val = param[1];
                var key = param[0];
                if (typeof val === "number" || !(val.TAG === /* Bool */4 && val._0)) {
                  return [
                          key,
                          "False"
                        ];
                } else {
                  return [
                          key,
                          "True"
                        ];
                }
              })) : []
    );
  var sets$1 = Belt_Array.map(tmp, (function (param) {
          return "-s " + name + ":" + param[0] + "=" + param[1];
        }));
  var opts = Yaml.get($$int, "options");
  var tmp$1;
  tmp$1 = typeof opts === "number" ? [] : (
      opts.TAG === /* Object */2 ? Belt_Array.map(Js_dict.entries(opts._0), (function (param) {
                var val = param[1];
                var key = param[0];
                if (typeof val === "number" || !(val.TAG === /* Bool */4 && val._0)) {
                  return [
                          key,
                          "False"
                        ];
                } else {
                  return [
                          key,
                          "True"
                        ];
                }
              })) : []
    );
  var opts$1 = Belt_Array.map(tmp$1, (function (param) {
          return "-o " + name + ":" + param[0] + "=" + param[1];
        }));
  return Flat.array([
              args$1,
              sets$1,
              opts$1
            ]);
}

function getRepo(folder) {
  return Belt_Result.map($$File.read(Path.join(folder, "conanfile.py")), (function (content) {
                if (content.includes("Proprietary")) {
                  return "$CONAN_REPO_INTERNAL";
                } else {
                  return "$CONAN_REPO_PUBLIC";
                }
              }));
}

function getVariables(param) {
  var args = param.args;
  var match = param.base;
  var version = match.version;
  var match$1 = version.match(/^[0-9a-f]{40}$/);
  return Belt_Array.concat(Belt_Array.concat([
                  [
                    "NAME",
                    match.name
                  ],
                  [
                    "VERSION",
                    version
                  ],
                  [
                    "FOLDER",
                    match.folder
                  ],
                  [
                    "REPO",
                    param.repo
                  ],
                  [
                    "PROFILE",
                    param.profile
                  ]
                ], args.length !== 0 ? [[
                      "ARGS",
                      Belt_Array.joinWith(args, " ", (function (str) {
                              return str;
                            }))
                    ]] : []), match$1 !== null ? [[
                  "UPLOAD_ALIAS",
                  "1"
                ]] : []);
}

function init(ints) {
  var exportPkgs = ints.reduce((function (pkgs, param) {
          var folder = param.folder;
          var version = param.version;
          var name = param.name;
          if (Belt_Array.some(pkgs, (function (pkg) {
                    return Caml_obj.caml_equal(pkg, [
                                name + "/" + version + "@",
                                folder
                              ]);
                  }))) {
            return pkgs;
          } else {
            return Belt_Array.concat(pkgs, [[
                          name + "/" + version + "@",
                          folder
                        ]]);
          }
        }), []);
  var match = Seq.option2([
        Caml_option.nullable_to_opt(Deno.env.get("CONAN_CONFIG_URL")),
        Caml_option.nullable_to_opt(Deno.env.get("CONAN_CONFIG_DIR"))
      ]);
  var config = TaskResult.flatMap(Task.resolve(match !== undefined ? ({
                TAG: /* Ok */0,
                _0: [
                  match[0],
                  match[1]
                ]
              }) : ({
                TAG: /* Error */1,
                _0: "Conan config url or dir not defined"
              })), (function (param) {
          return Proc.run([
                      "conan",
                      "config",
                      "install",
                      param[0],
                      "-sf",
                      param[1]
                    ]);
        }));
  return TaskResult.flatMap(TaskResult.flatMap(config, (function (param) {
                    var match = Seq.option([
                          Caml_option.nullable_to_opt(Deno.env.get("CONAN_LOGIN_USERNAME")),
                          Caml_option.nullable_to_opt(Deno.env.get("CONAN_LOGIN_PASSWORD")),
                          Caml_option.nullable_to_opt(Deno.env.get("CONAN_REPO_ALL"))
                        ]);
                    if (match === undefined) {
                      return Task.resolve({
                                  TAG: /* Error */1,
                                  _0: "Conan login, password or repo not defined"
                                });
                    }
                    if (match.length !== 3) {
                      return Task.resolve({
                                  TAG: /* Error */1,
                                  _0: "Conan login, password or repo not defined"
                                });
                    }
                    var user = match[0];
                    var passwd = match[1];
                    var repo = match[2];
                    return Proc.run([
                                "conan",
                                "user",
                                user,
                                "-p",
                                passwd,
                                "-r",
                                repo
                              ]);
                  })), (function (param) {
                return TaskResult.pool(Belt_Array.map(exportPkgs, (function (param, param$1) {
                                  return Proc.run([
                                              "conan",
                                              "export",
                                              param[1],
                                              param[0]
                                            ]);
                                })), navigator.hardwareConcurrency);
              }));
}

function getBuildOrder(ints) {
  var locks = Belt_Array.map(ints, (function (param) {
          var match = param.base;
          return match.name + "-" + match.version + "-" + param.hash + ".lock";
        }));
  console.log(locks);
  var bundle = locks.length !== 0 ? Proc.run(Belt_Array.concat([
              "conan",
              "lock",
              "bundle",
              "create",
              "--bundle-out=lock.bundle"
            ], locks)) : Task.resolve({
          TAG: /* Ok */0,
          _0: ""
        });
  return TaskResult.flatMap(TaskResult.flatMap(bundle, (function (param) {
                    return Proc.run([
                                "conan",
                                "lock",
                                "bundle",
                                "build-order",
                                "lock.bundle",
                                "--json=build_order.json"
                              ]);
                  })), (function (param) {
                return Task.resolve(Belt_Result.map($$File.read("build_order.json"), (function (content) {
                                  return JSON.parse(content);
                                })));
              }));
}

function getExtends(param) {
  var profile = param[0];
  var triple = Belt_List.fromArray(profile.split("-"));
  var arch;
  if (triple) {
    var match = triple.tl;
    if (match) {
      switch (match.hd) {
        case "armv8" :
            arch = {
              TAG: /* Ok */0,
              _0: "armv8"
            };
            break;
        case "wasm" :
        case "x86_64" :
            arch = {
              TAG: /* Ok */0,
              _0: "x86_64"
            };
            break;
        default:
          arch = {
            TAG: /* Error */1,
            _0: "Could not detect image arch for profile: " + profile
          };
      }
    } else {
      arch = {
        TAG: /* Error */1,
        _0: "Could not detect image arch for profile: " + profile
      };
    }
  } else {
    arch = {
      TAG: /* Error */1,
      _0: "Could not detect image arch for profile: " + profile
    };
  }
  var end = param[1] ? "-bootstrap" : "";
  return Belt_Result.map(arch, (function (arch) {
                return [".conan" + "-" + arch + end];
              }));
}

function getJob(ints, buildOrder) {
  return Flat.array(Belt_Array.mapWithIndex(buildOrder, (function (index, group) {
                    return Flat.array(Belt_Array.map(group, (function (pkg) {
                                      var match = pkg.split("#");
                                      if (match.length !== 2) {
                                        throw {
                                              RE_EXN_ID: "Match_failure",
                                              _1: [
                                                "Conan.res",
                                                200,
                                                10
                                              ],
                                              Error: new Error()
                                            };
                                      }
                                      var pkg$1 = match[0];
                                      var pkgRevision = match[1];
                                      var ints$1 = ints.filter(function (param) {
                                            var match = param.base;
                                            if (pkgRevision === param.revision) {
                                              return pkg$1 === match.name + "/" + match.version + "@";
                                            } else {
                                              return false;
                                            }
                                          });
                                      return Belt_Array.concat(Belt_Array.map(ints$1, (function ($$int) {
                                                        var group = Belt_Array.get(buildOrder, index - 1 | 0);
                                                        return {
                                                                name: $$int.base.name + "/" + $$int.base.version + "@" + $$int.hash,
                                                                extends: $$int.extends,
                                                                variables: Caml_option.some(Js_dict.fromArray(getVariables($$int))),
                                                                image: undefined,
                                                                tags: undefined,
                                                                script: undefined,
                                                                needs: Belt_Array.concat($$int.base.reqs, group !== undefined ? Belt_Array.map(group, (function (pkg) {
                                                                              var match = pkg.split("#");
                                                                              if (match.length !== 2) {
                                                                                throw {
                                                                                      RE_EXN_ID: "Match_failure",
                                                                                      _1: [
                                                                                        "Conan.res",
                                                                                        218,
                                                                                        20
                                                                                      ],
                                                                                      Error: new Error()
                                                                                    };
                                                                              }
                                                                              var pkg$1 = match[0];
                                                                              var ver = match[1];
                                                                              return pkg$1 + "#" + $$String.sub(ver, 0, 3);
                                                                            })) : [])
                                                              };
                                                      })), [{
                                                    name: pkg$1 + "#" + $$String.sub(pkgRevision, 0, 3),
                                                    extends: undefined,
                                                    variables: undefined,
                                                    image: undefined,
                                                    tags: ["x86_64"],
                                                    script: ["echo"],
                                                    needs: Belt_Array.map(ints$1, (function (foundPkg) {
                                                            return pkg$1 + foundPkg.hash;
                                                          }))
                                                  }]);
                                    })));
                  })));
}

function getConanInstances($$int) {
  var version = $$int.version;
  var name = $$int.name;
  var repo = getRepo($$int.folder);
  var args = getArgs(name, $$int.modeInt);
  return $$int.profiles.map(function (profile) {
              var $$extends = getExtends([
                    profile,
                    $$int.bootstrap
                  ]);
              return TaskResult.flatMap(Task.resolve(Seq.result2([
                                  $$extends,
                                  repo
                                ])), (function (param) {
                            var repo = param[1];
                            var $$extends = param[0];
                            var hash = Hash.hashN({
                                  base: $$int,
                                  extends: $$extends,
                                  hash: "",
                                  revision: "",
                                  profile: profile,
                                  repo: repo,
                                  args: args
                                }, 3);
                            return TaskResult.flatMap(TaskResult.flatMap(Proc.run(Belt_Array.concat([
                                                    "conan",
                                                    "lock",
                                                    "create",
                                                    "--ref=" + name + "/" + version,
                                                    "--build=" + name + "/" + version,
                                                    "--lockfile-out=" + name + "-" + version + "-" + hash + ".lock",
                                                    "-pr=" + profile
                                                  ], args)), (function (param) {
                                              return Task.resolve(Belt_Result.flatMap($$File.read(name + "-" + version + "-" + hash + ".lock"), (function (lock) {
                                                                var ref = Json.get(Json.get(Json.get(Json.get(Json.parse(lock), "graph_lock"), "nodes"), "1"), "ref");
                                                                if (typeof ref !== "number" && ref.TAG === /* String */0) {
                                                                  var revision = Belt_Array.get(ref._0.split("#"), 1);
                                                                  if (revision !== undefined) {
                                                                    return {
                                                                            TAG: /* Ok */0,
                                                                            _0: revision
                                                                          };
                                                                  } else {
                                                                    return {
                                                                            TAG: /* Error */1,
                                                                            _0: "Invalid lock file: " + name + "-" + version + "-" + hash + ".lock"
                                                                          };
                                                                  }
                                                                }
                                                                return {
                                                                        TAG: /* Error */1,
                                                                        _0: "Invalid lock file: " + name + "-" + version + "-" + hash + ".lock"
                                                                      };
                                                              })));
                                            })), (function (revision) {
                                          return Task.resolve({
                                                      TAG: /* Ok */0,
                                                      _0: {
                                                        base: $$int,
                                                        extends: $$extends,
                                                        hash: hash,
                                                        revision: revision,
                                                        profile: profile,
                                                        repo: repo,
                                                        args: args
                                                      }
                                                    });
                                        }));
                          }));
            });
}

function getJobs(ints) {
  var ints$1 = ints.filter(function ($$int) {
        return $$int.mode === "conan";
      });
  return TaskResult.flatMap(TaskResult.flatMap(init(ints$1), (function (param) {
                    return TaskResult.seq(Flat.array(Belt_Array.map(ints$1, getConanInstances)));
                  })), (function (ints) {
                var match = ints.length;
                if (match !== 0) {
                  return TaskResult.map(getBuildOrder(ints), (function (buildOrder) {
                                return getJob(ints, buildOrder);
                              }));
                } else {
                  return Task.resolve({
                              TAG: /* Ok */0,
                              _0: []
                            });
                }
              }));
}

var hashLength = 3;

export {
  hashLength ,
  hashN ,
  getArgs ,
  getRepo ,
  getVariables ,
  init ,
  getBuildOrder ,
  getExtends ,
  getJob ,
  getConanInstances ,
  getJobs ,
  
}
/* File Not a pure module */
