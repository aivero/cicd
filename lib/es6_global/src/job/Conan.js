// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Fs from "fs";
import * as $$File from "../std/File.js";
import * as Flat from "../std/Flat.js";
import * as Hash from "../std/Hash.js";
import * as Proc from "../std/Proc.js";
import * as Task from "../std/Task.js";
import * as Path from "path";
import * as Detect from "../Detect.js";
import * as $$String from "../../../../node_modules/rescript/lib/es6/string.js";
import * as Js_dict from "../../../../node_modules/rescript/lib/es6/js_dict.js";
import * as Caml_obj from "../../../../node_modules/rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "../../../../node_modules/rescript/lib/es6/belt_Array.js";
import * as TaskResult from "../std/TaskResult.js";
import * as Belt_Option from "../../../../node_modules/rescript/lib/es6/belt_Option.js";
import * as Belt_Result from "../../../../node_modules/rescript/lib/es6/belt_Result.js";
import * as Caml_option from "../../../../node_modules/rescript/lib/es6/caml_option.js";

function hashN(__x) {
  return Hash.hashN(__x, 4);
}

function getArgs($$int) {
  var args = Deno.env.get("args");
  var args$1 = (args == null) ? [] : args.split(" ");
  var match = $$int.name;
  var match$1 = $$int.settings;
  var sets = match !== undefined ? (
      match$1 !== undefined ? Belt_Array.map(Belt_Array.map(Js_dict.entries(Caml_option.valFromOption(match$1)), (function (param) {
                    var val = param[1];
                    return [
                            param[0],
                            val.toString() === "true" ? "True" : (
                                val.toString() === "false" ? "False" : val
                              )
                          ];
                  })), (function (param) {
                return "-s " + match + ":" + param[0] + "=" + param[1];
              })) : []
    ) : [];
  var match$2 = $$int.name;
  var match$3 = $$int.options;
  var opts = match$2 !== undefined ? (
      match$3 !== undefined ? Belt_Array.map(Belt_Array.map(Js_dict.entries(Caml_option.valFromOption(match$3)), (function (param) {
                    var val = param[1];
                    return [
                            param[0],
                            val.toString() === "true" ? "True" : (
                                val.toString() === "false" ? "False" : val
                              )
                          ];
                  })), (function (param) {
                return "-o " + match$2 + ":" + param[0] + "=" + param[1];
              })) : []
    ) : [];
  return Belt_Array.concatMany([
              args$1,
              sets,
              opts
            ]);
}

function getRepo($$int) {
  return Belt_Result.map($$File.read(Path.join(Belt_Option.getExn($$int.folder), "conanfile.py")), (function (content) {
                if (content.includes("Proprietary")) {
                  return "$CONAN_REPO_INTERNAL";
                } else {
                  return "$CONAN_REPO_PUBLIC";
                }
              }));
}

function getVariables(param) {
  var profile = param.profile;
  var $$int = param.int;
  return Belt_Result.map(getRepo($$int), (function (repo) {
                var match = $$int.name;
                var match$1 = $$int.version;
                var match$2 = $$int.folder;
                if (match !== undefined) {
                  if (match$1 !== undefined) {
                    if (match$2 !== undefined) {
                      return Belt_Array.concat([
                                  [
                                    "PKG",
                                    match + "/" + match$1
                                  ],
                                  [
                                    "FOLDER",
                                    match$2
                                  ],
                                  [
                                    "REPO",
                                    repo
                                  ],
                                  [
                                    "PROFILE",
                                    profile
                                  ]
                                ], getArgs($$int).length !== 0 ? [[
                                      "ARGS",
                                      Belt_Array.joinWith(getArgs($$int), " ", (function (str) {
                                              return str;
                                            }))
                                    ]] : []);
                    } else {
                      return [];
                    }
                  } else {
                    return [];
                  }
                } else {
                  return [];
                }
              }));
}

function getCmds(param) {
  var $$int = param.int;
  var initCmds = [
    "conan config install $CONAN_CONFIG_URL -sf $CONAN_CONFIG_DIR",
    "conan user $CONAN_LOGIN_USERNAME -p $CONAN_LOGIN_PASSWORD -r $CONAN_REPO_ALL",
    "conan user $CONAN_LOGIN_USERNAME -p $CONAN_LOGIN_PASSWORD -r $CONAN_REPO_INTERNAL",
    "conan user $CONAN_LOGIN_USERNAME -p $CONAN_LOGIN_PASSWORD -r $CONAN_REPO_PUBLIC",
    "conan config set general.default_profile=" + param.profile
  ];
  var repo = getRepo($$int);
  var args = getArgs($$int);
  var match = $$int.name;
  var match$1 = $$int.version;
  var match$2 = $$int.folder;
  var cmds;
  if (match !== undefined) {
    if (match$1 !== undefined) {
      if (match$2 !== undefined) {
        if (repo.TAG === /* Ok */0) {
          var repo$1 = repo._0;
          var createPkg = [Belt_Array.joinWith([
                    "conan",
                    "create",
                    "-u",
                    match$2,
                    match + "/" + match$1 + "@"
                  ].concat(args), " ", (function (str) {
                    return str;
                  }))];
          var createDbg = [Belt_Array.joinWith([
                    "conan",
                    "create",
                    match$2,
                    match + "-dbg/" + match$1 + "@"
                  ].concat(args), " ", (function (str) {
                    return str;
                  }))];
          var uploadPkg = [Belt_Array.joinWith([
                  "conan",
                  "upload",
                  match + "/" + match$1 + "@",
                  "--all",
                  "-c",
                  "-r",
                  repo$1
                ], " ", (function (str) {
                    return str;
                  }))];
          var match$3 = $$int.debugPkg;
          var uploadDbg = match$3 !== undefined ? (
              match$3 ? [Belt_Array.joinWith([
                        "conan",
                        "upload",
                        match + "-dbg/" + match$1 + "@",
                        "--all",
                        "-c",
                        "-r",
                        repo$1
                      ], " ", (function (str) {
                          return str;
                        }))] : []
            ) : [];
          cmds = Belt_Array.concatMany([
                createPkg,
                createDbg,
                uploadPkg,
                uploadDbg
              ]);
        } else {
          cmds = [];
        }
      } else {
        cmds = [];
      }
    } else {
      cmds = [];
    }
  } else {
    cmds = [];
  }
  return Belt_Array.concatMany([
              initCmds,
              cmds
            ]);
}

function getInfo(param) {
  var mode = param.mode;
  var profile = param.profile;
  var $$int = param.int;
  var match = $$int.name;
  var match$1 = $$int.version;
  if (match === undefined) {
    return Task.resolve({
                TAG: /* Error */1,
                _0: "Name or version not defined"
              });
  }
  if (match$1 === undefined) {
    return Task.resolve({
                TAG: /* Error */1,
                _0: "Name or version not defined"
              });
  }
  var hash = Hash.hashN({
        int: $$int,
        profile: profile,
        mode: mode
      }, 4);
  return TaskResult.flatMap(Proc.run(Belt_Array.concatMany([
                      [
                        "conan",
                        "info",
                        "-j",
                        match + "-" + match$1 + "-" + hash + ".json",
                        "-pr=" + profile
                      ],
                      getArgs($$int),
                      [match + "/" + match$1 + "@"]
                    ])), (function (param) {
                return Belt_Result.flatMap($$File.read(match + "-" + match$1 + "-" + hash + ".json"), (function (output) {
                              var find = JSON.parse(output).find(function (e) {
                                    return e.reference === match + "/" + match$1;
                                  });
                              if (find !== undefined) {
                                return {
                                        TAG: /* Ok */0,
                                        _0: {
                                          info: find === undefined ? undefined : Caml_option.some(find),
                                          int: $$int,
                                          profile: profile,
                                          mode: mode,
                                          hash: hash
                                        }
                                      };
                              } else {
                                return {
                                        TAG: /* Error */1,
                                        _0: "Couldn't find info for: " + match + "/" + match$1 + " (" + profile + ")"
                                      };
                              }
                            }));
              }));
}

function init(zips) {
  var match = Deno.env.get("CONAN_CONFIG_URL");
  var match$1 = Deno.env.get("CONAN_CONFIG_DIR");
  var match$2 = !(match == null) && !(match$1 == null) ? [
      match,
      match$1
    ] : [
      "",
      ""
    ];
  var config = Proc.run([
        "conan",
        "config",
        "install",
        match$2[0],
        "-sf",
        match$2[1]
      ]);
  var exportPkgs = zips.reduce((function (a, zip) {
          var match = zip.int.name;
          var match$1 = zip.int.version;
          var match$2 = zip.int.folder;
          if (match !== undefined && match$1 !== undefined && match$2 !== undefined && !Belt_Array.some(a, (function (e) {
                    return Caml_obj.caml_equal(e, [
                                match + "/" + match$1 + "@",
                                match$2
                              ]);
                  }))) {
            return Belt_Array.concat(a, [[
                          match + "/" + match$1 + "@",
                          match$2
                        ]]);
          } else {
            return a;
          }
        }), []);
  return Flat.task(TaskResult.map(config, (function (param) {
                    return TaskResult.pool(Belt_Array.map(exportPkgs, (function (param, param$1) {
                                      return Proc.run([
                                                  "conan",
                                                  "export",
                                                  param[1],
                                                  param[0]
                                                ]);
                                    })), 32);
                  })));
}

function getLockFile(pkgInfos) {
  return TaskResult.flatMap(Flat.task(TaskResult.map(Flat.task(TaskResult.map(Flat.task(TaskResult.map(pkgInfos, (function (pkgInfos) {
                                        return TaskResult.pool(Belt_Array.map(pkgInfos, (function (pkgInfo, param) {
                                                          var match = pkgInfo.int.name;
                                                          var match$1 = pkgInfo.int.version;
                                                          if (match !== undefined && match$1 !== undefined) {
                                                            return TaskResult.map(Proc.run(Belt_Array.concat([
                                                                                "conan",
                                                                                "lock",
                                                                                "create",
                                                                                "--ref=" + match + "/" + match$1,
                                                                                "--build=" + match + "/" + match$1,
                                                                                "--lockfile-out=" + match + "-" + match$1 + "-" + Hash.hashN(pkgInfo, 4) + ".lock",
                                                                                "-pr=" + pkgInfo.profile
                                                                              ], getArgs(pkgInfo.int))), (function (param) {
                                                                          return pkgInfo;
                                                                        }));
                                                          } else {
                                                            return Task.resolve({
                                                                        TAG: /* Error */1,
                                                                        _0: "This should not happen"
                                                                      });
                                                          }
                                                        })), 32);
                                      }))), (function (pkgInfos) {
                                var locks = Belt_Array.map(pkgInfos, (function (pkgInfo) {
                                        var match = pkgInfo.int.name;
                                        var match$1 = pkgInfo.int.version;
                                        if (match !== undefined && match$1 !== undefined) {
                                          return match + "-" + match$1 + "-" + Hash.hashN(pkgInfo, 4) + ".lock";
                                        } else {
                                          return "";
                                        }
                                      }));
                                console.log(locks);
                                if (locks.length !== 0) {
                                  return TaskResult.map(Proc.run(Belt_Array.concat([
                                                      "conan",
                                                      "lock",
                                                      "bundle",
                                                      "create",
                                                      "--bundle-out=lock.bundle"
                                                    ], locks)), (function (param) {
                                                return pkgInfos;
                                              }));
                                } else {
                                  return Task.resolve({
                                              TAG: /* Ok */0,
                                              _0: pkgInfos
                                            });
                                }
                              }))), (function (param) {
                        if (Fs.existsSync("lock.bundle")) {
                          return Proc.run([
                                      "conan",
                                      "lock",
                                      "bundle",
                                      "build-order",
                                      "lock.bundle",
                                      "--json=build_order.json"
                                    ]);
                        } else {
                          return Task.resolve({
                                      TAG: /* Ok */0,
                                      _0: ""
                                    });
                        }
                      }))), (function (param) {
                if (Fs.existsSync("build_order.json")) {
                  return Belt_Result.map($$File.read("build_order.json"), (function (content) {
                                return JSON.parse(content);
                              }));
                } else {
                  return {
                          TAG: /* Ok */0,
                          _0: []
                        };
                }
              }));
}

function getJob(buildOrder, pkgInfos) {
  return Belt_Result.map(Flat.array(Belt_Array.mapWithIndex(buildOrder, (function (index, group) {
                        return Belt_Result.map(Flat.array(Belt_Array.map(group, (function (pkg) {
                                              var match = pkg.split("#");
                                              if (match.length !== 2) {
                                                throw {
                                                      RE_EXN_ID: "Match_failure",
                                                      _1: [
                                                        "Conan.res",
                                                        256,
                                                        10
                                                      ],
                                                      Error: new Error()
                                                    };
                                              }
                                              var pkg$1 = match[0];
                                              var revision = match[1];
                                              var foundPkgs = pkgInfos.filter(function (e) {
                                                    if (revision === e.info.revision) {
                                                      return pkg$1 === e.info.reference + "@";
                                                    } else {
                                                      return false;
                                                    }
                                                  });
                                              return Flat.array(Belt_Array.concat(Belt_Array.map(foundPkgs, (function (foundPkg) {
                                                                    var hash = foundPkg.hash;
                                                                    var mode = foundPkg.mode;
                                                                    var profile = foundPkg.profile;
                                                                    var $$int = foundPkg.int;
                                                                    return Belt_Result.flatMap(Detect.getExtends({
                                                                                    int: $$int,
                                                                                    profile: profile,
                                                                                    mode: mode
                                                                                  }), (function ($$extends) {
                                                                                  return Belt_Result.map(getVariables({
                                                                                                  int: $$int,
                                                                                                  profile: profile,
                                                                                                  mode: mode
                                                                                                }), (function (variables) {
                                                                                                var needs = $$int.req;
                                                                                                var group = Belt_Array.get(buildOrder, index - 1 | 0);
                                                                                                return {
                                                                                                        name: Belt_Option.getExn($$int.name) + "/" + Belt_Option.getExn($$int.version) + "@" + hash,
                                                                                                        extends: $$extends,
                                                                                                        variables: Caml_option.some(Js_dict.fromArray(variables)),
                                                                                                        image: undefined,
                                                                                                        script: undefined,
                                                                                                        needs: Belt_Array.concat(needs !== undefined ? needs : [], group !== undefined ? Belt_Array.map(group, (function (pkg) {
                                                                                                                      var match = pkg.split("#");
                                                                                                                      if (match.length !== 2) {
                                                                                                                        throw {
                                                                                                                              RE_EXN_ID: "Match_failure",
                                                                                                                              _1: [
                                                                                                                                "Conan.res",
                                                                                                                                279,
                                                                                                                                22
                                                                                                                              ],
                                                                                                                              Error: new Error()
                                                                                                                            };
                                                                                                                      }
                                                                                                                      var pkg$1 = match[0];
                                                                                                                      var ver = match[1];
                                                                                                                      return pkg$1 + "#" + $$String.sub(ver, 0, 4);
                                                                                                                    })) : [])
                                                                                                      };
                                                                                              }));
                                                                                }));
                                                                  })), [{
                                                                TAG: /* Ok */0,
                                                                _0: {
                                                                  name: pkg$1 + "#" + $$String.sub(revision, 0, 4),
                                                                  extends: undefined,
                                                                  variables: undefined,
                                                                  image: undefined,
                                                                  script: ["echo"],
                                                                  needs: Belt_Array.map(foundPkgs, (function (foundPkg) {
                                                                          return pkg$1 + foundPkg.hash;
                                                                        }))
                                                                }
                                                              }]));
                                            }))), Belt_Array.concatMany);
                      }))), Belt_Array.concatMany);
}

function getJobs(zips) {
  var zips$1 = zips.filter(function (zip) {
        return zip.mode === "conan";
      });
  var pkgInfos = Flat.task(TaskResult.map(init(zips$1), (function (param) {
              return TaskResult.pool(Belt_Array.map(zips$1, (function (zip, param) {
                                return getInfo(zip);
                              })), 32);
            })));
  var lockfile = getLockFile(pkgInfos);
  return Task.map(Promise.all([
                  pkgInfos,
                  lockfile
                ]), (function (param) {
                var lockfile = param[1];
                var pkgInfos = param[0];
                if (pkgInfos.TAG === /* Ok */0) {
                  if (lockfile.TAG === /* Ok */0) {
                    return getJob(lockfile._0, pkgInfos._0);
                  } else {
                    return {
                            TAG: /* Error */1,
                            _0: lockfile._0
                          };
                  }
                } else {
                  return {
                          TAG: /* Error */1,
                          _0: pkgInfos._0
                        };
                }
              }));
}

var procs = 32;

var hashLength = 4;

export {
  procs ,
  hashLength ,
  hashN ,
  getArgs ,
  getRepo ,
  getVariables ,
  getCmds ,
  getInfo ,
  init ,
  getLockFile ,
  getJob ,
  getJobs ,
  
}
/* fs Not a pure module */
