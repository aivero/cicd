// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Int from "./Int.js";
import * as Task from "./Task.js";
import * as $$Array from "./Array.js";
import * as Curry from "../../../../node_modules/rescript/lib/es6/curry.js";
import * as Result from "./Result.js";
import * as Console from "./Console.js";

function flatten(to) {
  return Task.flatMap(to, (function (r) {
                if (r.TAG === /* Ok */0) {
                  return r._0;
                } else {
                  return Task.resolve({
                              TAG: /* Error */1,
                              _0: r._0
                            });
                }
              }));
}

function map(a, fn) {
  return Task.map(a, (function (res) {
                return Result.map(res, fn);
              }));
}

function flatMap(a, fn) {
  return flatten(Task.map(a, (function (res) {
                    return Result.map(res, fn);
                  })));
}

function pool(tasks, count) {
  var curTasks = Promise.all($$Array.map($$Array.slice(tasks, 0, count), (function (f) {
              return new Promise((function (resolve) {
                            return Curry._1(resolve, Curry._1(f, undefined));
                          }));
            })));
  var rest = $$Array.slice(tasks, count, $$Array.length(tasks) - count | 0);
  Console.log("pool: " + Int.toString($$Array.length(rest)));
  return flatten(Task.flatMap(curTasks, (function (res1) {
                    var tasks = Task.map(Promise.all(res1), Result.seq);
                    return map(tasks, (function (res1) {
                                  var match = $$Array.length(rest);
                                  if (match !== 0) {
                                    return Task.map(pool(rest, count), (function (res2) {
                                                  return Result.map(res2, (function (res2) {
                                                                return $$Array.flatten([
                                                                            res1,
                                                                            res2
                                                                          ]);
                                                              }));
                                                }));
                                  } else {
                                    return Task.resolve({
                                                TAG: /* Ok */0,
                                                _0: res1
                                              });
                                  }
                                }));
                  })));
}

function seq(a) {
  return Task.map(Promise.all(a), Result.seq);
}

function seq2(param) {
  return Task.map(Promise.all([
                  param[0],
                  param[1]
                ]), Result.seq2);
}

function seq3(param) {
  return Task.map(Promise.all([
                  param[0],
                  param[1],
                  param[2]
                ]), Result.seq3);
}

function seq4(param) {
  return Task.map(Promise.all([
                  param[0],
                  param[1],
                  param[2],
                  param[3]
                ]), Result.seq4);
}

var resolve = Task.resolve;

export {
  resolve ,
  flatten ,
  map ,
  flatMap ,
  pool ,
  seq ,
  seq2 ,
  seq3 ,
  seq4 ,
  
}
/* No side effect */
